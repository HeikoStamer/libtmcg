\input texinfo
@c %**start of header
@documentencoding ISO-8859-1
@setfilename libTMCG.info
@include version.texi
@settitle The LibTMCG Reference Manual
@c %**end of header

@c Include data type index into function index
@syncodeindex tp fn

@c A simple macro for optional variables. (copied from gcrypt manual)
@macro ovar{varname}
@r{[}@var{\varname\}@r{]}
@end macro

@copying
This is the reference manual of LibTMCG.

Revision $Id: libTMCG.texi,v 1.19 2006/03/09 21:50:10 stamer Exp $.

Copyright @copyright{} 2005, 2006 Heiko Stamer <@email{stamer@@gaos.org}>.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts. A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end quotation
@end copying

@titlepage
@title The LibTMCG Reference Manual
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Heiko Stamer <@email{stamer@@gaos.org}>

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top LibTMCG Reference Manual

@insertcopying
@end ifnottex

@c **********************************************************
@c *******************  Introduction  ***********************
@c **********************************************************
@chapter Introduction
`@acronym{LibTMCG}' is a general purpose C++ library for
creating secure electronic card games. The most remarkable
feature is the absence of a trusted third party (TTP), i.e.
neither a central game server nor similar facilities are
necessary. To emphasize this point again: With the present
library there is no need for an independent referee, because
the applied protocols provide a basic level of confidentiality
and fairness by itself. Of course, we cannot avoid that
malicious players share information about their private
cards, but the protocols ensure that the shuffle of the
deck is performed randomly (presumed that at least one
player is honest) and thus the cards will be distributed
uniformly among the players. Further, no coalition can
learn the private cards of a player agains his will (except
for trivial conclusions). The corresponding cryptographic
problem, actually called ''Mental Poker'', has been studied
since 1979 (Shamir, Rivest, and Adleman) by many authors.

Our implementation relies on advanced cryptographic
techniques---the so-called zero-knowledge proofs. Using
these `building blocks' the high-level protocols minimize
the effect of coalitions and preserve the confidentiality
of the players' strategy, i.e. the players are not required
to reveal their cards at the end of the game to show that
they did not cheat.

LibTMCG is @emph{Free Software} according to the definition
of the @uref{http://www.fsf.org/licensing/essays/free-sw.html,,
Free Software Foundation}.

@c **********************************************************
@section Further Reading
The cryptographic background and a detailed discussion of
the implementation issues is beyond the scope of this manual.
The interested reader is refered to the following papers:
@quotation [Sch98]
	@sc{Christian Schindelhauer}.
	@emph{Toolbox for Mental Card Games.}@*
	Technical Report A-98-14, University of L@"ubeck, 1998.
@end quotation
@quotation [BS03]
	@sc{Adam Barnett} and @sc{Nigel P. Smart}.
	@emph{Mental Poker Revisited.}@*
	In K.G. Paterson (Ed.): Cryptography and Coding 2003,
	Lecture Notes in Computer Science 2898, pp. 370--383, 2003.
@end quotation
@quotation [Gr05]
	@sc{Jens Groth}.
	@emph{A Verifiable Secret Shuffle of Homomorphic Encryptions.}@*
	Cryptology ePrint Archive, Report 2005/246, 2005.
@end quotation
@quotation [St04]
	@sc{Heiko Stamer}.
	@emph{Kryptographische Skatrunde.} (in German)@*
	Offene Systeme (ISSN 1619-0114), 4:10--30, 2004.@*
	@uref{http://www.gaos.org/~stamer/OS-4-2004-openskat_rev2005.pdf}
@end quotation
@quotation [St05]
	@sc{Heiko Stamer}.
	@emph{Efficient Electronic Gambling: An Extended Implementation
	of the Toolbox for Mental Card Games.}@*
	Proceedings of the Western European Workshop on Research in
	Cryptology (WEWoRC 2005), Lecture Notes in Informatics P-74,
	pp. 1--12, 2005.
@end quotation

@c **********************************************************
@section Getting Started
This manual describes the application programming interface
of LibTMCG. All relevant data types, public classes and
security parameters are explained. The reader should have
an advanced knowledge in applied cryptography and C++
programming. Reference is made at this point to the famous
@cite{Handbook of Applied Cryptography} for a brief
introduction.

This document follows, in style and rarely in phrasing,
the @cite{Reference Manual of the GNU Crypto Library}.
Thus don't be surprised, if you recognize some obvious
analogies.

@c **********************************************************
@section Preparation
LibTMCG depends on the two other basic libraries. Therefore
you will absolutely need the corresponding development
files to build LibTMCG and your application properly:
@itemize @bullet
	@item GNU Multiple Precision Arithmetic Library (@file{libgmp}),
		Version @math{\ge} 4.1.0
		
		This library provides a powerful framework for performing
		arbitrary precision arithmetic on integers. Further reasons
		for chosing this dependency are the license compatibility,
		portability, vital maintainance, and, of course, the
		reasonable performance.
		
	@item GNU Crypto Library (@file{libgcrypt}),
		Version @math{\ge} 1.2.0
		
		This library provides some basic cryptographic algorithms
		(e.g. RIPEMD-160) and an easily usable interface to obtain
		cryptographically strong pseudo random numbers.
		
@end itemize
We suppose that the reader is familiar with these libraries
because their correct installation and configuration is
crucial to the security of the entire application.

@c **********************************************************
@section Header Files and Namespaces
@cindex Header Files
@cindex Namespaces
The interface definitions of the classes and the constant security
parameters@footnote{These parameters are fixed at compile time.
Please don't change anything unless you know exactly what you are
doing, and what the dangers are! Beside the apparent security
concerns you will probably break the compatibility with other
applications.} are provided by the central header file
@file{libTMCG.hh}. You have to include this file in all of your
sources, either directly or through some other method.

@example
#include <libTMCG.hh>
@end example

There are no uniform C++ namespaces for the most parts of the
library. Some classes have the common prefix @code{TMCG_*} or
@code{VTMF_*} while others are composed of the author names
of the related research paper. Further there are internally
used C functions which might produce conflicting names. These
function names are prepended by @code{mpz_*} because they are
extensions for the integer support of the GNU Multiple Precision
Arithmetic Library.

@c **********************************************************
@section Building Sources
If you want to compile a source file including the @file{libTMCG.hh}
header file, you must make sure that the compiler can find it in the
directory hierarchy. This is accomplished by adding the path of the
corresponding directory to the compilers include file search path
(via the @option{-I} option).

However, the path to the include file is determined at the time the
source is configured. To solve this problem, LibTMCG ships with a small
helper program @command{libTMCG-config} that knows the path to the
include file and a few other configuration options. The options that
need to be added to the compiler invocation are output by the
@option{--cflags} option to @command{libTMCG-config}. The following
example shows how it can be used at the command line:

@example
g++ -c foo.cc `libTMCG-config --cflags`
@end example

Adding the output of @samp{libTMCG-config --cflags} to the compilers
command line will ensure that the compiler can find the library header
file.

A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files. For this to work,
the path to the library files has to be added to the library search
path (via the @option{-L} option). For this, the option @option{--libs}
of @command{libTMCG-config} can be used. For convenience, this option
also outputs all other options that are required to link the program
with the library (in particular, the @samp{-lTMCG} option). The example
shows how to link @file{foo.o} with LibTMCG to a program called
@command{foo}.

@example
g++ -o foo foo.o `libTMCG-config --libs`
@end example

Of course you can also combine both examples to a single command by
specifying both options to @command{libTMCG-config}:

@example
g++ -o foo foo.c `libTMCG-config --cflags --libs`
@end example

@c **********************************************************
@section Building Sources Using GNU Automake
You can use GNU Automake to obtain automatically generated
Makefiles. If you do that you do not have to worry about finding and
invoking the @command{libTMCG-config} script at all.
LibTMCG provides an Automake extension that does all the work for you.

@defmac AM_PATH_LIBTMCG (@ovar{minimum-version}, @ovar{action-if-found}, @ovar{action-if-not-found})
Check whether LibTMCG (at least version @var{minimum-version}, if given)
exists on the host system. If it is found, execute @var{action-if-found},
otherwise do @var{action-if-not-found}.

Additionally, the function defines @code{LIBTMCG_CFLAGS} to the
flags needed for compilation of the program to find the necessary header
files, and @code{LIBTMCG_LIBS} to the linker flags needed to link the
program with the library.
@end defmac

You can use the defined variables in @file{Makefile.am} like below:

@example
AM_CPPFLAGS = $(LIBTMCG_CFLAGS)
LDADD = $(LIBTMCG_LIBS)
@end example

@c **********************************************************
@section Initializing the Library
The first step is the initalization of LibTMCG. The following
function must be invoked early in your program, i.e. before
you make use of any other capability.

@deftypefun bool init_libTMCG ()
The function checks whether the installed third-party libraries
match their required versions. Further it initalize them
and returns @code{true}, if everything was sound. Otherwise
@code{false} is returned and an appropriate error message
is sent to @code{stderr}.
@end deftypefun

@c **********************************************************
@c *************************  API  **************************
@c **********************************************************
@chapter Application Programming Interface

@c **********************************************************
@section Preprocessor Defined Global Symbols
@cindex Security Parameters
Please note that the following macros are fixed at compile
time of LibTMCG and cannot be changed in your application.
They are only provided here for informational purposes.

@defmac TMCG_GROTH_L_E
Defines the security parameter @math{\ell_e} of Groth's interactive
shuffle argument@tie{}[Gr05]. The default value is @code{80L} which
implies a soundness error probability @math{{} \le 2^{-80}}. For the
intended purpose of this library the chosen bound seems to be
reasonable small enough.
@end defmac

@defmac TMCG_DDH_SIZE
Defines the security parameter (field size in bit) of the DDH-hard
group @math{G} which is used by the card encoding scheme of Barnett
and Smart@tie{}[BS03]. The underlying assumptions are DDH, CDH, and DLOG.
The default value is @code{1024L}.
@end defmac

@defmac TMCG_DLSE_SIZE
Defines the security parameter (subgroup size in bit) of the group
@math{G} which is used by the card encoding scheme of Barnett and
Smart@tie{}[BS03]. The underlying assumptions are DLSE (related to DDH),
and DLOG. The default value is @code{160L}.
@end defmac

@defmac TMCG_GCRY_MD_ALGO
Defines the message digest algorithm for digital signatures and
the Fiat-Shamir heuristic. The security proofs of the most non-interactive
zero-knowledge proofs (NIZK) are established in the so-called random
oracle model, i.e. one supposes that the used hash function behaves
like an ideal random function (which cannot exist in a real world scenario).
However, this assumption seems to be reasonable, if carefully implemented.
The default value is @code{GCRY_MD_RMD160}. This constant represents
the hash algorithm RIPEMD-160 which has an output length of 160 bit.
Thus it leads to a security level of approximately @math{2^{80}}, assuming
that a birthday-attack is the best known attack agains this algorithm.
@end defmac

@defmac TMCG_KEYID_SIZE
Defines the length (in characters w.r.t. @code{TMCG_MPZ_IO_BASE})
of the distinctive suffix for the unique key identifier. The default
value is @code{5} which spans a reasonable name space for at least
4096 different keys.

Each key identifier starts with the string @code{ID} followed by
the decimal coded value @code{TMCG_KEYID_SIZE} and an appended
carret symbol @code{^}. The final suffix consists of number
@code{TMCG_KEYID_SIZE} characters of the self signature.
@end defmac

@defmac TMCG_KEY_NIZK_STAGE1
Defines the security parameter (number of iterations) of the NIZK
proof (stage 1) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{16} which implies
a soundness error probability @math{{} \le d^{-16}}, where
@math{d = {\rm gcd}(m, \phi(m))}. This parameter is only relevant for the
card encoding scheme of Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_KEY_NIZK_STAGE2
Defines the security parameter (number of iterations) of the NIZK
proof (stage 2) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{128} which implies
a soundness error probability @math{{} \le 2^{-128}}.
This parameter is only relevant for the card encoding scheme of
Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_KEY_NIZK_STAGE3
Defines the security parameter (number of iterations) of the NIZK
proof (stage 3) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{128} which implies
a soundness error probability @math{{} \le 2^{-128}}.
This parameter is only relevant for the card encoding scheme of
Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_LIBGCRYPT_VERSION
Defines the necessary minimum version of the GNU Crypto Library.
The default value is @code{"1.2.0"}. During the initalization of
LibTMCG it is checked whether the version number of the currently
available shared object is greater or equal.
@end defmac

@defmac TMCG_LIBGMP_VERSION
Defines the necessary minimum version of the GNU Multiple Precision
Arithmetic Library. The default value is @code{"4.1.0"}. During the
initalization of LibTMCG it is checked whether the version number of
the header file used at compile time is greater or equal.
@end defmac

@defmac TMCG_MAX_CARDS
Defines the maximum number of stackable cards.
The default value is @code{128L}.
@end defmac

@defmac TMCG_MAX_PLAYERS
Defines the maximum number of participating players in the scheme of
Schindelhauer@tie{}[Sc98]. The default value is @code{32L}.
@end defmac

@defmac TMCG_MAX_TYPEBITS
Defines the number of bits to represent the card type in the scheme of
Schindelhauer@tie{}[Sc98]. The default value @code{8L} implies that 256
different cards are possible.
@end defmac

@defmac TMCG_MPZ_IO_BASE
Defines the input/ouput encoding base of the @code{iostream} operators
for arbitrary precision integers. The default value @code{36L} is currently
the largest base supported by the GNU Multiple Precision Arithmetic Library.
@end defmac

@defmac TMCG_PRAB_K0
Defines the security parameter @math{k_0} (in characters) for the PRab
digital signature scheme of Bellare and Rogaway. The default value is
@code{20} which leads to a security level of approximately @math{2^{80}}.
@end defmac

@defmac TMCG_QRA_SIZE
Defines the security parameter (size of the modulus @math{m = p \cdot q}
in bit) of the TMCG key. The underlying assumptions are QRA and FAKTOR.
The default value is @code{1024L}. This parameter is mostly relevant
for the card encoding scheme of Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_SAEP_S0
Defines the security parameter @math{s_0} (in characters) for the Rabin-SAEP
encryption scheme of Boneh. The default value @code{20} implies a security
around @math{2^{80}} against @acronym{CCA, Chosen Ciphertext Attacks}.
@end defmac

@defmac TMCG_HASH_COMMITMENT
Defines whether or not shortened commitments are used by the shuffle
proof of Schindelhauer@tie{}[Sc98]. The default value is @code{true},
because it decreases the communication complexity enormously. However,
as a consequence the soundness property of the proof only remains valid
in the random oracle model.
@end defmac

@defmac TMCG_MAX_FPOWM_T
Defines the maximum size of a possible exponent (in bit) used with the
fast exponentiation procedures based on precomputated tables.
The default value is @code{2048}.
@end defmac

@c **********************************************************
@section Public Data Types and Classes

@subsection Data Types
@cindex Data Types

@subsubsection Encoding Schemes for Cards
@cindex Card Encoding Schemes
There are two different encoding schemes that can be used
as digital representation of playing cards. In the
scheme of Schindelhauer@tie{}[Sc98] the type of a card is
shared among the players through bitwise representation
by quadratic (non-)residues. Thus the security relies on
the well-known @acronym{QRA, Quadratic Residuosity Assumption}.
Unfortunately, the size of a card grows linearly in the
number of players and logarithmically in the number of
different card types. Recently the much more efficient
solution of Barnett and Smart@tie{}[BS03] has been
implemented. This encoding works on a cyclic group of
prime order and requires that the @acronym{DDH, Decisional
Diffie-Hellman Assumption} holds there.

For both schemes there is a data type with the suffix
@code{Card} which represents an open or masked card.
Further, there is corresponding type with the suffix
@code{CardSecret} that represents the secret involved
in a card masking operation.

Because of the reduced computational and communication
complexity (cf.@tie{}[St05]) the usage of the second card
encoding scheme, i.e. @code{VTMF_Card}, is highly recommended.

@deftp {Data type} TMCG_Card
This @code{struct} represents a card in the encoding scheme
of Schindelhauer@tie{}[Sc98]. The type of the card is shared
among the players by quadratic residues and non-residues,
respectively. The security relies on the Quadratic Residuosity
Assumption.
	@deftypecv {Member} TMCG_Card {std::vector< std::vector<MP_INT> >} z
	This @math{k\times w}-matrix encodes the type of the
	corresponding card in a shared way. For each of the
	@math{k} players there is a separate row and for each of
	the @math{w} bits in the binary representation of the
	type there is a column. The elements are numbers from
	the group @math{{\bf Z}^{\circ}_{m_i}} where @math{m_i}
	is the public modulus of the @math{i}th player.
	@end deftypecv
	
	@defop {Constructor} TMCG_Card TMCG_Card ()
	This default constructor initalizes the card with an empty
	@math{1\times 1}-matrix. Later the method
	@code{TMCG_Card::resize} can be used to enlarge the
	card representation.
	@end defop
	
	@defop {Constructor} TMCG_Card TMCG_Card (@code{size_t} k, @code{size_t} w)
	This constructor initalizes the card with an empty
	@math{k\times w}-matrix. The parameter @var{k} is the
	number of players and @var{w} is the maximum number
	of bits used by the binary representation of the card
	type.
	@end defop
	
	@deftypeop {Constructor} TMCG_Card {} TMCG_Card (@code{const TMCG_Card&} that)
	This is a simple copy-constructor and @var{that} is the card to be
	copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Card TMCG_Card& = (@code{const TMCG_Card&} that)
	This is a simple assignment-operator and @var{that} is the card to
	be assigned.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Card bool == (@code{const TMCG_Card&} that)
	This operator tests two card representations for equality.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Card bool != (@code{const TMCG_Card&} that)
	This operator tests two card representations for inequality.
	@end deftypeop
	
	@deftypemethod TMCG_Card void resize (@code{size_t} k, @code{size_t} w)
	This method resizes the representation of the card.
	The current content of the member @code{z} will be
	released and a new @math{k\times w}-matrix is created.
	The parameter @var{k} is the number of players and
	@var{w} is the maximum number of bits used by the binary
	representation of the card type.
	@end deftypemethod
	
	@deftypemethod TMCG_Card bool import (@code{std::string} s)
	This method imports the content of the member @code{z} from
	the correctly formated input string @var{s}. It returns
	@code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_Card ~TMCG_Card ()
	This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_Card std::ostream& << (@code{std::ostream&} out, @code{const TMCG_Card&} card)
	This operator exports the content of the member @code{z}
	(of the given @code{TMCG_Card} @var{card}) to the output
	stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_Card std::istream& >> (@code{std::istream&} in, @code{TMCG_Card&} card)
	This operator imports the content of the member @code{z}
	(of the given @code{TMCG_Card} @var{card}) from the input
	stream @var{in}. The data has to be delimited by a newline
	character. The @code{failbit} of the stream is set, if any
	parse error occured.
@end deftypeop

@deftp {Data type} TMCG_CardSecret
This @code{struct} represents the secret used for a card masking
operation in the original encoding scheme of Schindelhauer@tie{}[Sc98].
	@deftypecv {Member} TMCG_CardSecret {std::vector< std::vector<MP_INT> >} r
	This @math{k\times w}-matrix encodes the first part of the
	secret. For each of the @math{k} players there is a separate
	row and for each of the @math{w} bits in the binary representation
	of the corresponding card type there is a column. The elements are
	numbers from the group @math{{\bf Z}^{\circ}_{m_i}} where @math{m_i}
	is the public modulus of the @math{i}th player.
	@end deftypecv
	
	@deftypecv {Member} TMCG_CardSecret {std::vector< std::vector<MP_INT> >} b
	This @math{k\times w}-matrix encodes the second part of the
	secret. For each of the @math{k} players there is a separate
	row and for each of the @math{w} bits in the binary representation
	of the corresponding card type there is a column. The elements are
	simply numbers from @math{\{0, 1\}}.
	@end deftypecv
	
	@defop {Constructor} TMCG_CardSecret TMCG_CardSecret ()
	This default constructor initalizes both members with an empty
	@math{1\times 1}-matrix. Later the method
	@code{TMCG_CardSecret::resize} can be used to enlarge the
	card representation.
	@end defop
	
	@defop {Constructor} TMCG_CardSecret TMCG_CardSecret (@code{size_t} k, @code{size_t} w)
	This constructor initalizes both members with an empty
	@math{k\times w}-matrix. The parameter @var{k} is the
	number of players and @var{w} is the maximum number
	of bits used by the binary representation of the
	corresponding card type.
	@end defop
	
	@deftypeop {Constructor} TMCG_CardSecret {} TMCG_CardSecret (@code{const TMCG_CardSecret&} that)
	This is a simple copy-constructor and @var{that} is the secret to be
	copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_CardSecret TMCG_CardSecret& = (@code{const TMCG_CardSecret&} that)
	This is a simple assignment-operator and @var{that} is the secret to
	be assigned.
	@end deftypeop
	
	@deftypemethod TMCG_CardSecret void resize (@code{size_t} k, @code{size_t} w)
	This method resizes the representation of the secret.
	The current content of the members @code{r} and @code{b}
	will be released and new @math{k\times w}-matrices are
	created. The parameter @var{k} is the number of players and
	@var{w} is the maximum number of bits used by the binary
	representation of the corresponding card type.
	@end deftypemethod
	
	@deftypemethod TMCG_CardSecret bool import (@code{std::string} s)
	This method imports the content of the members @code{r} and
	@code{b} from the correctly formated input string @var{s}.
	It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_CardSecret ~TMCG_CardSecret ()
	This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_CardSecret std::ostream& << (@code{std::ostream&} out, @code{const TMCG_CardSecret&} cardsecret)
	This operator exports the content of the members @code{r}
	and @code{b} (of the given @code{TMCG_CardSecret}
	@var{cardsecret}) to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_CardSecret std::istream& >> (@code{std::istream&} in, @code{TMCG_CardSecret&} cardsecret)
	This operator imports the content of the members @code{r}
	and @code{b} (of the given @code{TMCG_CardSecret}
	@var{cardsecret}) from the input stream @var{in}.
	The data has to be delimited by a newline character.
	The @code{failbit} of the stream is set, if any parse error
	occured.
@end deftypeop

@deftp {Data type} VTMF_Card
This @code{struct} represents a card in the encoding scheme
of Barnett and Smart@tie{}[BS03]. We use the discrete logarithm
based instantiation of their general cryptographic primitive
@acronym{VTMF, Verifiable @var{k}-out-of-@var{k} Threshold Masking
Function}. The security relies on the DDH assumption in the
underlying group @math{G}.
	@deftypecv {Member} VTMF_Card {mpz_t} c_1
	This is the first part of the encrypted card type.
	It is a number from the underlying group @math{G}.
	@end deftypecv
	
	@deftypecv {Member} VTMF_Card {mpz_t} c_2
	This is the second part of the encrypted card type.
	It is a number from the underlying group @math{G}.
	@end deftypecv
	
	@defop {Constructor} VTMF_Card VTMF_Card ()
	This default constructor initalizes the card with empty
	members @code{c_1} and @code{c_2}.
	@end defop
	
	@deftypeop {Constructor} VTMF_Card {} VTMF_Card (@code{const VTMF_Card&} that)
	This is a simple copy-constructor and @var{that} is the
	card to be copied.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_Card VTMF_Card& = (@code{const VTMF_Card&} that)
	This is a simple assignment-operator and @var{that} is
	the card to be assigned.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_Card bool == (@code{const VTMF_Card&} that)
	This operator tests two card representations for equality.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_Card bool != (@code{const VTMF_Card&} that)
	This operator tests two card representations for inequality.
	@end deftypeop
	
	@deftypemethod VTMF_Card bool import (@code{std::string} s)
	This method imports the content of the members @code{c_1}
	and @code{c_2} from the correctly formated input string
	@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} VTMF_Card ~VTMF_Card ()
	This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} VTMF_Card std::ostream& << (@code{std::ostream&} out, @code{const VTMF_Card&} card)
	This operator exports the content of the members @code{c_1}
	and @code{c_2} (of the given @code{VTMF_Card} @var{card})
	to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} VTMF_Card std::istream& >> (@code{std::istream&} in, @code{VTMF_Card&} card)
	This operator imports the content of the members @code{c_1}
	and @code{c_2} (of the given @code{VTMF_Card} @var{card})
	from the input stream @var{in}. The data has to be delimited
	by a newline character. The @code{failbit} of the stream is
	set, if any parse error occured.
@end deftypeop

@deftp {Data type} VTMF_CardSecret
This @code{struct} represents the secret used for the card masking
operation in the encoding scheme of Barnett and Smart@tie{}[BS03].
	@deftypecv {Member} VTMF_CardSecret {mpz_t} r
	This member is the exponent (randomizer) used in the masking operation.
	It should be chosen uniformly and randomly from @math{{\bf Z}_q}
	where @math{q} is the order of the finite abelian group @math{G}
	for which the DDH assumption should hold.
	
	According to the results of Koshiba and Kurosawa (see PKC@tie{}2004,
	LNCS@tie{}2947) the length of this exponent can be shorten to a reasonable
	value (e.g. 160@tie{}bit), if the corresponding generator is adjusted
	as well. Under the additional @acronym{DLSE, Discret Logarithm with Short
	Exponents} assumption the corresponding DDH problem in @math{G} seems
	to be still hard enough. By such an optimization trick we gain a great
	performance advantage for almost all modular exponentiations.
	@end deftypecv
	
	@defop {Constructor} VTMF_CardSecret VTMF_CardSecret ()
	This default constructor initalizes the secret with an
	empty member @code{r}.
	@end defop
	
	@deftypeop {Constructor} VTMF_CardSecret {} VTMF_CardSecret (@code{const VTMF_CardSecret&} that)
	This is a simple copy-constructor and @var{that} is the secret to be
	copied.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_CardSecret VTMF_CardSecret& = (@code{const VTMF_CardSecret&} that)
	This is a simple assignment-operator and @var{that} is the secret to
	be assigned.
	@end deftypeop
	
	@deftypemethod VTMF_CardSecret bool import (@code{std::string} s)
	This method imports the content of the member @code{r}
	from the correctly formated input string @var{s}.
	It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} VTMF_CardSecret ~VTMF_CardSecret ()
	This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} VTMF_CardSecret std::ostream& << (@code{std::ostream&} out, @code{const VTMF_CardSecret&} cardsecret)
	This operator exports the content of the member @code{r}
	(of the given @code{VTMF_CardSecret} @var{cardsecret})
	to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} VTMF_CardSecret std::istream& >> (@code{std::istream&} in, @code{VTMF_CardSecret&} cardsecret)
	This operator imports the content of the member @code{r}
	(of the given @code{VTMF_CardSecret} @var{cardsecret})
	from the input stream @var{in}. The data has to be
	delimited by a newline character. The @code{failbit} of
	the stream is set, if any parse error occured.
@end deftypeop

@subsubsection Cryptographic Keys
@cindex Keys


@subsection Classes
@cindex Classes

@chapter Examples
@cindex Examples
Please have a look at the several examples in the directory
@file{tests} and the commented source code. A detailed
exposition with some code fragments will later be included here.


@c **********************************************************
@c *******************  Appendices  *************************
@c **********************************************************
@include gpl.texi
@include fdl.texi

@unnumbered General Index
@printindex cp

@unnumbered API Index
@printindex fn

@bye
