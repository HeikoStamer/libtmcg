\input texinfo
@c %**start of header
@documentencoding ISO-8859-1
@setfilename libTMCG.info
@include version.texi
@settitle The LibTMCG Reference Manual
@c %**end of header

@c Include data type index into function index
@syncodeindex tp fn

@c A simple macro for optional variables. (copied from gcrypt manual)
@macro ovar{varname}
@r{[}@var{\varname\}@r{]}
@end macro

@copying
This is the reference manual of LibTMCG.

Revision $Id: libTMCG.texi,v 1.21 2006/03/25 19:57:17 stamer Exp $.

Copyright @copyright{} 2005, 2006 Heiko Stamer <@email{stamer@@gaos.org}>.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts. A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end quotation
@end copying

@titlepage
@title The LibTMCG Reference Manual
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Heiko Stamer <@email{stamer@@gaos.org}>

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top LibTMCG Reference Manual

@insertcopying
@end ifnottex

@c **********************************************************
@c *******************  Introduction  ***********************
@c **********************************************************
@chapter Introduction
`@acronym{LibTMCG}' is a general purpose C++ library for
creating secure electronic card games. The most remarkable
feature is the absence of a trusted third party (TTP), i.e.
neither a central game server nor trusted hardware components
are necessary. To emphasize this point again: With the present
library there is no need for an independent referee, because
the applied protocols provide a basic level of confidentiality
and fairness by itself. Of course, we cannot avoid that
malicious players share information about their private
cards, but the protocols ensure that the shuffle of the
deck is performed randomly (presumed that at least one
player is honest) and thus the cards will be distributed
uniformly among the players. Further, no coalition can
learn the private cards of a player against his will (except
for trivial conclusions). The corresponding cryptographic
problem, actually called ''Mental Poker'', has been studied
since 1979 (Shamir, Rivest, and Adleman) by many authors.

Our implementation relies on advanced cryptographic
techniques---the so-called zero-knowledge proofs. Using
these `building blocks' the high-level protocols minimize
the effect of coalitions and preserve the confidentiality
of the players' strategy, i.e. the players are not required
to reveal their cards at the end of the game to show that
they did not cheat.

LibTMCG is @emph{Free Software} according to the definition
of the @uref{http://www.fsf.org/licensing/essays/free-sw.html,,
Free Software Foundation}. The source code is released under
the GNU @emph{General Public License} Version 2.

@c **********************************************************
@section Further Reading
The cryptographic background and a detailed discussion of
the implementation issues is beyond the scope of this manual.
The interested reader is referred to the following papers:
@quotation [Sch98]
	@sc{Christian Schindelhauer}.
	@emph{Toolbox for Mental Card Games.}@*
	Technical Report A-98-14, University of L@"ubeck, 1998.
@end quotation
@quotation [BS03]
	@sc{Adam Barnett} and @sc{Nigel P. Smart}.
	@emph{Mental Poker Revisited.}@*
	In K.G. Paterson (Ed.): Cryptography and Coding 2003,
	Lecture Notes in Computer Science 2898, pp. 370--383, 2003.
@end quotation
@quotation [Gr05]
	@sc{Jens Groth}.
	@emph{A Verifiable Secret Shuffle of Homomorphic Encryptions.}@*
	Cryptology ePrint Archive, Report 2005/246, 2005.
@end quotation
@quotation [St04]
	@sc{Heiko Stamer}.
	@emph{Kryptographische Skatrunde.} (in German)@*
	Offene Systeme (ISSN 1619-0114), 4:10--30, 2004.@*
	@uref{http://www.gaos.org/~stamer/OS-4-2004-openskat_rev2005.pdf}
@end quotation
@quotation [St05]
	@sc{Heiko Stamer}.
	@emph{Efficient Electronic Gambling: An Extended Implementation
	of the Toolbox for Mental Card Games.}@*
	Proceedings of the Western European Workshop on Research in
	Cryptology (WEWoRC 2005), Lecture Notes in Informatics P-74,
	pp. 1--12, 2005.
@end quotation

@c **********************************************************
@section Getting Started
This manual describes the application programming interface
of LibTMCG. All relevant data types, public classes and
security parameters are explained. The reader should have
an advanced knowledge in applied cryptography and C++
programming. Reference is made at this point to the famous
@cite{Handbook of Applied Cryptography} for a brief
introduction.

This document follows, in style and rarely in phrasing,
the @cite{Reference Manual of the GNU Crypto Library}.
Thus don't be surprised, if you recognize some obvious
analogies.

@c **********************************************************
@section Preparation
LibTMCG depends on the three other basic libraries. Therefore
you need the corresponding development files to build LibTMCG
and your application properly:
@itemize @bullet
	@item GNU Multiple Precision Arithmetic Library (@file{libgmp}),
		Version @math{\ge} 4.1.0
		
		This library provides a powerful framework for performing
		arbitrary precision arithmetic on integers. Further reasons
		for choosing this dependency are the license compatibility,
		portability, vital maintenance, and, of course, the
		reasonable performance.
		
	@item GNU Crypto Library (@file{libgcrypt}),
		Version @math{\ge} 1.2.0
		
		This library provides some basic cryptographic algorithms
		(e.g. RIPEMD-160) and an easily usable interface to obtain
		cryptographically strong pseudo random numbers.
	
	@item GNU Privacy Guard Error Code Library (@file{libgpg-error}),
		Version @math{\ge} 0.5
		
		This library defines common error values, e.g., returned by the
		GNU Crypto Library.
@end itemize
We suppose that the reader is familiar with these libraries
because their correct installation and configuration is
crucial to the security of the entire application.

@c **********************************************************
@section Header Files and Name Spaces
@cindex Header Files
@cindex Name Spaces
The interface definitions of the classes and the security
parameters@footnote{These parameters are fixed at compile time.
Please don't change anything unless you know exactly what you are
doing, and what the dangers are! Beside the apparent security
concerns you will probably break the compatibility with other
LibTMCG applications.} are provided by the central header file
@file{libTMCG.hh}. You have to include this file in all of your
sources, either directly or through some other file.

@example
#include <libTMCG.hh>
@end example

There are no uniform C++ name spaces for the most parts of the
library. Some classes have the common prefix @code{TMCG_*} or
@code{VTMF_*} while others are composed of the author names
and the title abbreviation of the related research paper.
Further there are internally
used C functions which might produce conflicting names. These
function names are prepended by @code{mpz_*} because they are
extensions for the large integer support of the GNU Multiple
Precision Arithmetic Library.

@c **********************************************************
@section Building Sources
If you want to compile a source file including the @file{libTMCG.hh}
header file, you must make sure that the compiler can find it in the
directory hierarchy. This is accomplished by adding the path of the
corresponding directory to the compilers include file search path
(via the @option{-I} option).

However, the path to the include file is determined at the time the
source is configured. To solve this problem, LibTMCG ships with a small
helper program @command{libTMCG-config} that knows the path to the
include file and a few other configuration options. The options that
need to be added to the compiler invocation are output by the
@option{--cflags} option to @command{libTMCG-config}. The following
example shows how it can be used at the command line:

@example
g++ -c foo.cc `libTMCG-config --cflags`
@end example

Adding the output of @samp{libTMCG-config --cflags} to the compilers
command line will ensure that the compiler can find the library header
file.

A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files. For this to work,
the path to the library files has to be added to the library search
path (via the @option{-L} option). For this, the option @option{--libs}
of @command{libTMCG-config} can be used. For convenience, this option
also outputs all other options that are required to link the program
with the library (in particular, the @samp{-lTMCG} option). The example
shows how to link @file{foo.o} with LibTMCG to a program called
@command{foo}.

@example
g++ -o foo foo.o `libTMCG-config --libs`
@end example

Of course you can also combine both examples to a single command by
specifying both options to @command{libTMCG-config}:

@example
g++ -o foo foo.c `libTMCG-config --cflags --libs`
@end example

@c **********************************************************
@section Building Sources Using GNU Automake
You can use GNU Automake to obtain automatically generated
Makefiles. If you do that you do not have to worry about finding and
invoking the @command{libTMCG-config} script at all.
LibTMCG provides an Automake extension that does all the work for you.

@defmac AM_PATH_LIBTMCG (@ovar{minimum-version}, @ovar{action-if-found}, @ovar{action-if-not-found})
Check whether LibTMCG (at least version @var{minimum-version}, if given)
exists on the host system. If it is found, execute @var{action-if-found},
otherwise do @var{action-if-not-found}.

Additionally, the function defines @code{LIBTMCG_CFLAGS} to the
flags needed for compilation of the program to find the necessary header
files, and @code{LIBTMCG_LIBS} to the linker flags needed to link the
program with the library.
@end defmac

You can use the defined variables in @file{Makefile.am} like below:

@example
AM_CPPFLAGS = $(LIBTMCG_CFLAGS)
LDADD = $(LIBTMCG_LIBS)
@end example

@c **********************************************************
@section Initializing the Library
The first step is the initialization of LibTMCG. The following
function must be invoked early in your program, i.e. before
you make use of any other capability of LibTMCG.

@deftypefun bool init_libTMCG ()
The function checks whether the installed third-party libraries
match their required versions. Further it initialize them
and returns @code{true}, if everything was sound. Otherwise
@code{false} is returned and an appropriate error message
is sent to @code{stderr}.
@end deftypefun

@c **********************************************************
@c *************************  API  **************************
@c **********************************************************
@chapter Application Programming Interface

@c **********************************************************
@section Preliminaries
The most card games are played with a regular card deck, i.e.,
cards where the pattern on the picture sides determine the card
type (e.g. the King of Spades) and the reverse sides of all cards
in the deck are indistinguishable.

@c **********************************************************
@section Preprocessor Defined Global Symbols
@cindex Security Parameters
Please note that the following macros are fixed at compile
time of LibTMCG and cannot be changed by your application.
They are only provided here for informational purposes.

@defmac TMCG_MR_ITERATIONS
	Defines the number of iterations for the Miller-Rabin primality test.
	The default value is @code{64L} which implies a soundness error
	probability @math{{} \le 4^{-64}}.
@end defmac

@defmac TMCG_GROTH_L_E
	Defines the security parameter @math{\ell_e} of Groth's interactive
	shuffle argument@tie{}[Gr05]. The default value is @code{80L} which
	implies a soundness error probability @math{{} \le 2^{-80}}. For the
	intended purpose of LibTMCG this bound seems to be reasonable small
	enough.
@end defmac

@defmac TMCG_DDH_SIZE
Defines the security parameter (field size in bit) of the DDH-hard
group @math{G} which is used by the card encoding scheme of Barnett
and Smart@tie{}[BS03]. The underlying assumptions are DDH, CDH, and DLOG.
The default value is @code{1024L}.
@end defmac

@defmac TMCG_DLSE_SIZE
Defines the security parameter (subgroup size in bit) of the group
@math{G} which is used by the card encoding scheme of Barnett and
Smart@tie{}[BS03]. The underlying assumptions are DLSE (related to DDH)
and DLOG. The default value is @code{160L}.
@end defmac

@defmac TMCG_GCRY_MD_ALGO
Defines the message digest algorithm for digital signatures and
the Fiat-Shamir heuristic. The security of the most non-interactive
zero-knowledge proofs (NIZK) is proved in the so-called random
oracle model, i.e. one supposes that the used hash function behaves
like an ideal random function (which cannot exist in a real world scenario).
However, this assumption seems to be reasonable, if the hash function
is carefully implemented.
The default value is @code{GCRY_MD_RMD160}. This constant (from the
GNU Crypto Library) represents the hash algorithm RIPEMD-160 which has
an output length of 160 bit. Thus it leads to a security level of
approximately @math{2^{80}}, assuming that a birthday-attack is the
best known attack against this algorithm.
@end defmac

@defmac TMCG_KEYID_SIZE
Defines the length (in characters w.r.t. @code{TMCG_MPZ_IO_BASE})
of the distinctive suffix for the unique key identifier. The default
value is @code{8} which spans a reasonable name space for at least
@math{2^{20}} different keys.

Each key identifier starts with the string @code{ID} followed by
the decimal coded value @code{TMCG_KEYID_SIZE} and an appended
carret symbol @code{^}. The final suffix consists of number
@code{TMCG_KEYID_SIZE} alphanumerical characters of the self signature.
This suffix has enough entropy included to be used as unique key
identifier.
@end defmac

@defmac TMCG_KEY_NIZK_STAGE1
Defines the security parameter (number of iterations) of the NIZK
proof (stage 1) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{16} which implies
a soundness error probability @math{{} \le d^{-16}}, where
@math{d = {\rm gcd}(m, \phi(m))}. This parameter is only relevant for the
card encoding scheme of Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_KEY_NIZK_STAGE2
Defines the security parameter (number of iterations) of the NIZK
proof (stage 2) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{128} which implies
a soundness error probability @math{{} \le 2^{-128}}.
This parameter is only relevant for the card encoding scheme of
Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_KEY_NIZK_STAGE3
Defines the security parameter (number of iterations) of the NIZK
proof (stage 3) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{128} which implies
a soundness error probability @math{{} \le 2^{-128}}.
This parameter is only relevant for the card encoding scheme of
Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_LIBGCRYPT_VERSION
Defines the necessary minimum version of the GNU Crypto Library.
The default value is @code{"1.2.0"}. During the initialization of
LibTMCG it is checked whether the version number of the currently
available shared object is greater or equal.
@end defmac

@defmac TMCG_LIBGMP_VERSION
Defines the necessary minimum version of the GNU Multiple Precision
Arithmetic Library. The default value is @code{"4.1.0"}. During the
initialization of LibTMCG it is checked whether the version number of
the header file used at compile time is greater or equal.
@end defmac

@defmac TMCG_MAX_CARDS
Defines the maximum number of stackable cards.
The default value is @code{128L}.
@end defmac

@defmac TMCG_MAX_PLAYERS
Defines the maximum number of participating players in the scheme of
Schindelhauer@tie{}[Sc98]. The default value is @code{32L}.
@end defmac

@defmac TMCG_MAX_TYPEBITS
Defines the maximum number of bits to represent the card type in the
scheme of Schindelhauer@tie{}[Sc98]. Further, this value determines
the maximum size of the message space for the scheme of Barnett and
Smart@tie{}[BS03]. The default value @code{8L} implies that 256
different card types are possible.
@end defmac

@defmac TMCG_MPZ_IO_BASE
Defines the input/output encoding base of the @code{iostream} operators
for arbitrary precision integers. The default value @code{36L} is currently
the largest base supported by the GNU Multiple Precision Arithmetic Library.
@end defmac

@defmac TMCG_PRAB_K0
Defines the security parameter @math{k_0} (in characters) for the PRab
digital signature scheme of Bellare and Rogaway. The default value is
@code{20} which leads to a security level of approximately @math{2^{80}}.
@end defmac

@defmac TMCG_QRA_SIZE
Defines the security parameter (size of the modulus @math{m = p \cdot q}
in bit) of the TMCG key. The underlying assumptions are QRA and FACTOR.
The default value is @code{1024L}. This parameter is only relevant
for the card encoding scheme of Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_SAEP_S0
Defines the security parameter @math{s_0} (in characters) for the Rabin-SAEP
encryption scheme of Boneh. The default value @code{20} implies a security
around @math{2^{80}} against @acronym{CCA, Chosen Ciphertext Attacks}.
@end defmac

@defmac TMCG_HASH_COMMITMENT
Defines whether or not shortened commitments are used by the shuffle
proof of Schindelhauer@tie{}[Sc98]. The default value is @code{true},
because it decreases the communication complexity enormously. However,
as a consequence the soundness property of the proof only remains valid
in the random oracle model.
@end defmac

@defmac TMCG_MAX_FPOWM_T
Defines the maximum size of a possible exponent (in bit) used with the
fast exponentiation procedures based on precomputed tables.
The default value is @code{2048}.
@end defmac

@c **********************************************************
@section Public Data Types and Classes
This section describes the important data types and classes
that are necessary to create a secure card game. Private methods
and internally used members are not explained.

@subsection Data Types
@cindex Data Types
LibTMCG provides several data types for playing cards, stacks, and
cryptographic keys.

@subsubsection Encoding Schemes for Cards
@cindex Card Encoding Schemes
There are two different encoding schemes that can be used
for the digital representation of playing cards. In the
scheme of Schindelhauer@tie{}[Sc98] the type of a card is
shared among the players through bit-wise representation
by quadratic (non-)residues. Thus the security relies on
the well-known @acronym{QRA, Quadratic Residuosity Assumption}.
Unfortunately, the size of a card grows linearly in the
number of players and logarithmically in the number of
different card types. Recently the much more efficient
solution of Barnett and Smart@tie{}[BS03] has been
implemented. This encoding works on a cyclic group of
prime order and requires that the @acronym{DDH, Decisional
Diffie-Hellman Assumption} holds there.

For both schemes there is a data type with the suffix
@code{Card} which represents an open or even a masked card.
Further, there is corresponding data type with the suffix
@code{CardSecret} that represents the secret values involved
in a card masking operation.

Because of the reduced computational and communication
complexity (cf.@tie{}[St05]) the usage of the second card
encoding scheme, i.e. @code{VTMF_Card}, is highly recommended.

@deftp {Data type} TMCG_Card
	This @code{struct} represents a card in the encoding scheme
	of Schindelhauer@tie{}[Sc98]. The type of the card is shared
	among the players by quadratic residues and non-residues,
	respectively. Thus the security relies on the Quadratic
	Residuosity Assumption.
	
	@deftypecv {Member} TMCG_Card {std::vector< std::vector<MP_INT> >} z
		This @math{k\times w}-matrix encodes the type of the
		corresponding card in a shared way. For each of the
		@math{k} players there is a separate row and for each of
		the @math{w} bits in the binary representation of the
		type there is a column. The elements are numbers from
		the group @math{{\bf Z}^{\circ}_{m_i}} where @math{m_i}
		is the public modulus of the @math{i}th player.
	@end deftypecv
	
	@defop {Constructor} TMCG_Card TMCG_Card ()
		This default constructor initializes the card with an empty
		@math{1\times 1}-matrix. Later the method
		@code{TMCG_Card::resize} can be used to enlarge the
		card representation.
	@end defop
	
	@defop {Constructor} TMCG_Card TMCG_Card (@code{size_t} k, @code{size_t} w)
		This constructor initializes the card with an empty
		@math{k\times w}-matrix. The parameter @var{k} is the
		number of players and @var{w} is the maximum number
		of bits used by the binary representation of the card
		type.
	@end defop
	
	@deftypeop {Constructor} TMCG_Card {} TMCG_Card (@code{const TMCG_Card&} that)
		This is a simple copy-constructor and @var{that} is the card to be
		copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Card TMCG_Card& = (@code{const TMCG_Card&} that)
		This is a simple assignment-operator and @var{that} is the card to
		be assigned.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Card bool == (@code{const TMCG_Card&} that)
		This operator tests two card representations for equality.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Card bool != (@code{const TMCG_Card&} that)
		This operator tests two card representations for inequality.
	@end deftypeop
	
	@deftypemethod TMCG_Card void resize (@code{size_t} k, @code{size_t} w)
		This method resizes the representation of the card.
		The current content of the member @code{z} will be
		released and a new @math{k\times w}-matrix is created.
		The parameter @var{k} is the number of players and
		@var{w} is the maximum number of bits used by the binary
		representation of the card type.
	@end deftypemethod
	
	@deftypemethod TMCG_Card bool import (@code{std::string} s)
		This method imports the content of the member @code{z} from
		the correctly formated input string @var{s}. It returns
		@code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_Card ~TMCG_Card ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_Card std::ostream& << (@code{std::ostream&} out, @code{const TMCG_Card&} card)
	This operator exports the content of the member @code{z}
	(of the given @code{TMCG_Card} @var{card}) to the output
	stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_Card std::istream& >> (@code{std::istream&} in, @code{TMCG_Card&} card)
	This operator imports the content of the member @code{z}
	(of the given @code{TMCG_Card} @var{card}) from the input
	stream @var{in}. The data has to be delimited by a newline
	character. The @code{failbit} of the stream is set, if any
	parse error occurred.
@end deftypeop

@deftp {Data type} TMCG_CardSecret
	This @code{struct} represents the secret used for a card masking
	operation in the original encoding scheme of Schindelhauer@tie{}[Sc98].
	
	@deftypecv {Member} TMCG_CardSecret {std::vector< std::vector<MP_INT> >} r
		This @math{k\times w}-matrix encodes the first part of the
		secret. For each of the @math{k} players there is a separate
		row and for each of the @math{w} bits in the binary representation
		of the corresponding card type there is a column. The elements are
		numbers from the group @math{{\bf Z}^{\circ}_{m_i}} where @math{m_i}
		is the public modulus of the @math{i}th player.
	@end deftypecv
	
	@deftypecv {Member} TMCG_CardSecret {std::vector< std::vector<MP_INT> >} b
		This @math{k\times w}-matrix encodes the second part of the
		secret. For each of the @math{k} players there is a separate
		row and for each of the @math{w} bits in the binary representation
		of the corresponding card type there is a column. The elements are
		simply numbers from @math{\{0, 1\}}.
	@end deftypecv
	
	@defop {Constructor} TMCG_CardSecret TMCG_CardSecret ()
		This default constructor initializes both members with an empty
		@math{1\times 1}-matrix. Later the method
		@code{TMCG_CardSecret::resize} can be used to enlarge the
		card representation.
	@end defop
	
	@defop {Constructor} TMCG_CardSecret TMCG_CardSecret (@code{size_t} k, @code{size_t} w)
		This constructor initializes both members with an empty
		@math{k\times w}-matrix. The parameter @var{k} is the
		number of players and @var{w} is the maximum number
		of bits used by the binary representation of the
		corresponding card type.
	@end defop
	
	@deftypeop {Constructor} TMCG_CardSecret {} TMCG_CardSecret (@code{const TMCG_CardSecret&} that)
		This is a simple copy-constructor and @var{that} is the secret to be
		copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_CardSecret TMCG_CardSecret& = (@code{const TMCG_CardSecret&} that)
		This is a simple assignment-operator and @var{that} is the secret to
		be assigned.
	@end deftypeop
	
	@deftypemethod TMCG_CardSecret void resize (@code{size_t} k, @code{size_t} w)
		This method resizes the representation of the secret.
		The current content of the members @code{r} and @code{b}
		will be released and new @math{k\times w}-matrices are
		created. The parameter @var{k} is the number of players and
		@var{w} is the maximum number of bits used by the binary
		representation of the corresponding card type.
	@end deftypemethod
	
	@deftypemethod TMCG_CardSecret bool import (@code{std::string} s)
		This method imports the content of the members @code{r} and
		@code{b} from the correctly formated input string @var{s}.
		It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_CardSecret ~TMCG_CardSecret ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_CardSecret std::ostream& << (@code{std::ostream&} out, @code{const TMCG_CardSecret&} cardsecret)
	This operator exports the content of the members @code{r}
	and @code{b} (of the given @code{TMCG_CardSecret}
	@var{cardsecret}) to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_CardSecret std::istream& >> (@code{std::istream&} in, @code{TMCG_CardSecret&} cardsecret)
	This operator imports the content of the members @code{r}
	and @code{b} (of the given @code{TMCG_CardSecret}
	@var{cardsecret}) from the input stream @var{in}.
	The data has to be delimited by a newline character.
	The @code{failbit} of the stream is set, if any parse error
	occurred.
@end deftypeop

@deftp {Data type} VTMF_Card
	This @code{struct} represents a card in the encoding scheme
	of Barnett and Smart@tie{}[BS03]. Here we use the discrete logarithm
	based instantiation of their general cryptographic primitive
	@acronym{VTMF, Verifiable @var{k}-out-of-@var{k} Threshold Masking
	Function}. The security relies on the DDH assumption in the
	underlying abelian group @math{G}.
	
	@deftypecv {Member} VTMF_Card {mpz_t} c_1
		This is the first part of the encrypted card type.
		It is an element from the underlying group @math{G}.
	@end deftypecv
	
	@deftypecv {Member} VTMF_Card {mpz_t} c_2
		This is the second part of the encrypted card type.
		It is also an element from the underlying group @math{G}.
	@end deftypecv
	
	@defop {Constructor} VTMF_Card VTMF_Card ()
		This default constructor initializes an empty card where
		the members @code{c_1} and @code{c_2} are set to zero.
	@end defop
	
	@deftypeop {Constructor} VTMF_Card {} VTMF_Card (@code{const VTMF_Card&} that)
		This is a simple copy-constructor and @var{that} is the
		card to be copied.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_Card VTMF_Card& = (@code{const VTMF_Card&} that)
		This is a simple assignment-operator and @var{that} is
		the card to be assigned.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_Card bool == (@code{const VTMF_Card&} that)
		This operator tests two card representations for equality.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_Card bool != (@code{const VTMF_Card&} that)
		This operator tests two card representations for inequality.
	@end deftypeop
	
	@deftypemethod VTMF_Card bool import (@code{std::string} s)
		This method imports the content of the members @code{c_1}
		and @code{c_2} from a correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} VTMF_Card ~VTMF_Card ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} VTMF_Card std::ostream& << (@code{std::ostream&} out, @code{const VTMF_Card&} card)
	This operator exports the content of the members @code{c_1}
	and @code{c_2} (of the given @code{VTMF_Card} @var{card})
	to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} VTMF_Card std::istream& >> (@code{std::istream&} in, @code{VTMF_Card&} card)
	This operator imports the content of the members @code{c_1}
	and @code{c_2} (of the given @code{VTMF_Card} @var{card})
	from the input stream @var{in}. The data has to be delimited
	by a newline character. The @code{failbit} of the stream is
	set, if any parse error occurred.
@end deftypeop

@deftp {Data type} VTMF_CardSecret
	This @code{struct} represents the secrets used in the card masking
	operation by the encoding scheme of Barnett and Smart@tie{}[BS03].
	
	@deftypecv {Member} VTMF_CardSecret {mpz_t} r
		This member is the exponent (randomizer) used in the masking operation.
		It should be chosen uniformly and randomly from @math{{\bf Z}_q}
		where @math{q} is the order of the finite abelian group @math{G}
		for which the DDH assumption should hold.
		
		According to the results of Koshiba and Kurosawa (see PKC@tie{}2004,
		LNCS@tie{}2947) the length of this exponent can be shorten to a reasonable
		value (e.g. 160@tie{}bit), if the corresponding generator @math{g} is
		adjusted as well. Under the additional @acronym{DLSE, Discrete Logarithm
		with Short Exponents} assumption the actually used DDH problem in @math{G}
		seems to be still hard enough. By such an optimization trick we gain a
		great performance advantage for almost all modular exponentiations.
	@end deftypecv
	
	@defop {Constructor} VTMF_CardSecret VTMF_CardSecret ()
		This default constructor initializes the secret with an
		empty member @code{r}.
	@end defop
	
	@deftypeop {Constructor} VTMF_CardSecret {} VTMF_CardSecret (@code{const VTMF_CardSecret&} that)
		This is a simple copy-constructor and @var{that} is the secret to be
		copied.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_CardSecret VTMF_CardSecret& = (@code{const VTMF_CardSecret&} that)
		This is a simple assignment-operator and @var{that} is the secret to
		be assigned.
	@end deftypeop
	
	@deftypemethod VTMF_CardSecret bool import (@code{std::string} s)
		This method imports the content of the member @code{r}
		from the correctly formated input string @var{s}.
		It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} VTMF_CardSecret ~VTMF_CardSecret ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} VTMF_CardSecret std::ostream& << (@code{std::ostream&} out, @code{const VTMF_CardSecret&} cardsecret)
	This operator exports the content of the member @code{r}
	(of the given @code{VTMF_CardSecret} @var{cardsecret})
	to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} VTMF_CardSecret std::istream& >> (@code{std::istream&} in, @code{VTMF_CardSecret&} cardsecret)
	This operator imports the content of the member @code{r}
	(of the given @code{VTMF_CardSecret} @var{cardsecret})
	from the input stream @var{in}. The data has to be
	delimited by a newline character. The @code{failbit} of
	the stream is set, if any parse error occurred.
@end deftypeop

@subsubsection Stacks
@cindex Stacks
All of the following data types are generic containers that can be
instantiated as C++ templates with the former explained @code{Card}
and @code{CardSecret} data types, respectively.

@deftp {Data type} TMCG_Stack<@var{CardType}>
	This @code{struct} is a simple container for cards of the specified
	@code{@var{CardType}}. Currently, the elements can be either of type
	@code{TMCG_Card} or @code{VTMF_Card} depending on which kind of encoding
	scheme is used. The @code{TMCG_Stack} structure is mainly used to represent
	a stack of masked cards, i.e. playing cards that are stacked in a face-down
	manner. It can be either a public stack where all participants have access to
	or even a private stack, e.g., the players' hand. If the corresponding
	card types are known it can also serve as an ``open stack'', although
	@code{TMCG_OpenStack} is more suitable in that case.
	
	@deftypecv {Member} TMCG_Stack {std::vector<@var{CardType}>} stack
		This is the container that is used internally for storing the cards.
	@end deftypecv
	
	@defop {Constructor} TMCG_Stack TMCG_Stack ()
		This default constructor initializes an empty stack.
	@end defop
	
	@deftypeop {Operator} TMCG_Stack TMCG_Stack& = (@code{const TMCG_Stack<@var{CardType}>&} that)
		This is a simple assignment-operator and @var{that} is the stack to
		be assigned.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Stack bool == (@code{const TMCG_Stack<@var{CardType}>&} that)
		This operator tests two stacks for equality. It checks whether the
		sizes of the stacks and the contained cards are equal with respect to
		the implied order.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Stack bool != (@code{const TMCG_Stack<@var{CardType}>&} that)
		This operator tests two stacks for inequality. It returns @code{true}, if
		either the sizes does not match or at least two corresponding cards are
		not equal.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Stack {const @var{CardType}&} [] (@code{size_t} n)
		This operator provides read-only random access to the contained cards.
		It returns a const-reference to the @var{n}th card from the top of the stack.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Stack {@var{CardType}&} [] (@code{size_t} n)
		This operator provides random access to the contained cards.
		It returns a reference to the @var{n}th card from the top of the stack.
	@end deftypeop
	
	@deftypemethod TMCG_Stack size_t size ()
		This method returns the size of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack void push (@code{const @var{CardType}&} c)
		This method pushes the card @var{c} to the back of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack void push (@code{const TMCG_Stack<@var{CardType}>&} s)
		This method pushes the stack @var{s} to the back of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack void push (@code{const TMCG_OpenStack<@var{CardType}>&} s)
		This method pushes the cards of the open stack @var{s} to the back
		of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool empty ()
		This method returns @code{true}, if the stack is empty.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool pop (@code{@var{CardType}&} c)
		This method removes a card from the back and stores the data in @var{c}.
		It returns @code{true}, if the stack was not empty and thus @var{c}
		contains useful data.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack void clear ()
		This method clears the stack, i.e., it removes all cards.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool find (@code{const @var{CardType}&} c)
		This method returns @code{true}, if the card @var{c} was found in the
		stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool remove (@code{const @var{CardType}&} c)
		This method removes the top-most card from the stack which is equal to
		@var{c}. It returns @code{true}, if the card was found and successfully
		removed.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack size_t removeAll (@code{const @var{CardType}&} c)
		This method removes every card from the stack which is equal to @var{c}.
		It returns the number of removed cards.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool import (@code{std::string} s)
		This method imports the stack from the correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_Stack ~TMCG_Stack ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_Stack std::ostream& << (@code{std::ostream&} out, @code{const TMCG_Stack<@var{CardType}>&} stack)
	This operator exports the given @var{stack} to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_Stack std::istream& >> (@code{std::istream&} in, @code{TMCG_Stack<@var{CardType}>&} stack)
	This operator imports the given @var{stack} from the input stream @var{in}.
	The data has to be delimited by a newline character. The @code{failbit} of
	the stream is set, if any parse error occurred.
@end deftypeop

@deftp {Data type} TMCG_OpenStack<@var{CardType}>
	This @code{struct} is a simple container for cards of the specified
	@code{@var{CardType}} whose types are known. The elements are pairs where
	the first component is the type and the second component is the corresponding
	card. The card type is represented by a @code{size_t} integer. Currently, the
	cards can be either of type @code{TMCG_Card} or @code{VTMF_Card} depending on
	which kind of encoding scheme is used.
	
	@deftypecv {Member} TMCG_OpenStack {std::vector<std::pair<size_t, @var{CardType}> >} stack
		This is the container that is used internally for storing the pairs.
	@end deftypecv
	
	@defop {Constructor} TMCG_OpenStack TMCG_OpenStack ()
		This default constructor initializes an empty stack.
	@end defop
	
	@deftypeop {Operator} TMCG_OpenStack TMCG_OpenStack& = (@code{const TMCG_OpenStack<@var{CardType}>&} that)
		This is a simple assignment-operator and @var{that} is the stack to
		be assigned.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_OpenStack bool == (@code{const TMCG_OpenStack<@var{CardType}>&} that)
		This operator tests two stacks for equality. It checks whether the types,
		the sizes, and the contained cards are equal with respect to the stack order.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_OpenStack bool != (@code{const TMCG_OpenStack<@var{CardType}>&} that)
		This operator tests two stacks for inequality. It returns @code{true}, if
		either the sizes resp. types does not match or at least two corresponding cards
		are not equal.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_OpenStack {const std::pair<size_t, @var{CardType}>&} [] (@code{size_t} n)
		This operator provides read-only random access to the contained pairs.
		It returns a const-reference to the @var{n}th pair from the top of the stack.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_OpenStack {std::pair<size_t, @var{CardType}>&} [] (@code{size_t} n)
		This operator provides random access to the contained pairs.
		It returns a reference to the @var{n}th pair from the top of the stack.
	@end deftypeop
	
	@deftypemethod TMCG_OpenStack size_t size ()
		This method returns the size of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack void push (@code{const std::pair<size_t, @var{CardType}>&} p)
		This method pushes the pair @var{p} to the back of the stack. The first
		component is the type and the second component is the corresponding card
		representation.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack void push (@code{size_t} type, @code{const @var{CardType}&} c)
		This method pushes a pair to the back of the stack. The parameter @var{type}
		is the card type and @var{c} is the corresponding card representation.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack void push (@code{const TMCG_OpenStack<@var{CardType}>&} s)
		This method pushes the pairs of the stack @var{s} to the back
		of this stack.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool empty ()
		This method returns @code{true}, if the stack is empty.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool pop (@code{size_t&} type, @code{@var{CardType}&} c)
		This method removes a pair from the back of the stack. It stores the card type
		in @var{type} and the	representation in @var{c}. It returns @code{true}, if the stack
		was not empty and thus @var{type} and @var{c} contain useful data.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack void clear ()
		This method clears the stack, i.e., it removes all pairs.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool find (@code{size_t} type)
		This method returns @code{true}, if a pair with the first component @var{type} was
		found in the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool remove (@code{size_t} type)
		This method removes the top-most pair with the first component @var{type} from the
		stack. It returns @code{true}, if such a pair was found and successfully removed.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack size_t removeAll (@code{size_t} type)
		This method removes every pair from the stack whose first component is equal to
		@var{type}. Further it returns the number of removed pairs.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool move (@code{size_t} type, @code{TMCG_Stack<@var{CardType}>&} s)
	This method moves the top-most card representation of the given @var{type} to another
	stack @var{s}. It returns @code{true}, if such a pair was found and successfully moved.
	@end deftypemethod
	
	@defop {Destructor} TMCG_OpenStack ~TMCG_OpenStack ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftp {Data type} TMCG_StackSecret<@var{CardSecretType}>
	This @code{struct} is a simple container for the secrets involved
	in the masking operation of cards. Additionally, the permutation
	of a corresponding shuffle of the stack is stored.
	The elements are pairs where the first component is a permutation
	index of type @code{size_t} and the second component is a card
	secret of the specified @code{@var{CardSecretType}}. Currently,
	such secrets can be either of type @code{TMCG_CardSecret} or
	@code{VTMF_CardSecret} depending on which kind of encoding scheme
	is used.
	
	@deftypecv {Member} TMCG_StackSecret {std::vector<std::pair<size_t, @var{CardSecretType}> >} stack
		This is the container that is used internally for storing the pairs.
	@end deftypecv
	
	@defop {Constructor} TMCG_StackSecret TMCG_StackSecret ()
		This default constructor initializes an empty stack secret.
	@end defop
	
	@deftypeop {Operator} TMCG_StackSecret TMCG_StackSecret& = (@code{const TMCG_StackSecret<@var{CardSecretType}>&} that)
		This is a simple assignment-operator and @var{that} is the
		stack secret to be assigned.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_StackSecret {const std::pair<size_t, @var{CardSecretType}>&} [] (@code{size_t} n)
		This operator provides read-only random access to the contained pairs.
		It returns a const-reference to the @var{n}th pair from the top of the stack secret.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_StackSecret {std::pair<size_t, @var{CardSecretType}>&} [] (@code{size_t} n)
		This operator provides random access to the contained pairs.
		It returns a reference to the @var{n}th pair from the top of the stack secret.
	@end deftypeop
	
	@deftypemethod TMCG_StackSecret size_t size ()
		This method returns the size of the stack secret.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret void push (@code{size_t} index, @code{const @var{CardSecretType}&} cs)
		This method pushes a pair to the back of the stack secret. The parameter @var{index}
		is the permutation index and @var{cs} is the corresponding card secret.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret void clear ()
		This method clears the stack secret, i.e., it removes all pairs.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret size_t find_position (@code{size_t} index)
		This method searches for a given permutation index in the stack secret.
		It returns the corresponding position@footnote{According to the behaviour
		of the @code{[]}-operator, the zero denotes always the top-most position.} in
		the stack secret, if the @var{index} was found. Otherwise, the size of
		the stack secret is returned. Please note that in this case the returned
		value is not a valid position for an access to the stack secret.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret bool find (@code{size_t} index)
		This method searches for a given permutation index in the stack secret.
		It returns @code{true}, if such an @var{index} was found.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret bool import (@code{std::string} s)
		This method imports the stack secret from a correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_StackSecret ~TMCG_StackSecret ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_StackSecret std::ostream& << (@code{std::ostream&} out, @code{const TMCG_StackSecret<@var{CardSecretType}>&} stacksecret)
	This operator exports the given @var{stacksecret} to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_StackSecret std::istream& >> (@code{std::istream&} in, @code{TMCG_StackSecret<@var{CardSecretType}>&} stacksecret)
	This operator imports the given @var{stacksecret} from the input stream @var{in}.
	The data has to be delimited by a newline character. The @code{failbit} of
	the stream is set, if any parse error occurred.
@end deftypeop

@subsubsection Cryptographic Keys
@cindex Keys
LibTMCG only provides the key data types for the encoding scheme of Schindelhauer@tie{}[Sc98],
because it is very inefficient to perform the corresponding key generation in every new game
session. Furthermore, the keys can be used to ensure the confidentiality and integrity of short
messages, even if the scheme of Barnett and Smart@tie{}[BS03] has been applied for the card
encoding. Therefore these structures may be of independent interest. However, like in every
public key cryptosystem a trusted @acronym{PKI, Public Key Infrastructure} is needed. This
may not be a serious concern, if the players compare their key fingerprints over a secure
channel or if the service provider exhibits public key certificates.

@deftp {Data type} TMCG_SecretKey
	This @code{struct} represents the secret part of the TMCG key. The underlying public key
	cryptosystem is due to Rabin with minor modifications for encryption padding (SAEP scheme
	of Boneh) and digital signatures (PRab scheme of Bellare and Rogaway).
	
	@deftypecv {Member} TMCG_SecretKey {std::string} name
		This string contains the name or a pseudonym of the key owner.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {std::string} email
		This string contains the email address of the key owner.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {std::string} type
		This string contains information about the key type. The common
		prefix is @code{TMCG/RABIN}. It is followed by the decimal encoded
		bit size of the modulus @math{m}. The suffix @code{NIZK} signals
		that the correctness of the key is shown by an appended non-interactive
		zero-knowledge proof. The single parts are separated by underscore
		characters @code{_}, e.g., @code{TMCG/RABIN_1024_NIZK} has the correct
		form.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {std::string} nizk
		This string contains two stages of non-interactive zero-knowledge
		proof of Gennaro, Micciancio and Rabin (ACM CCS, 1998). They show
		that the modulus @math{m} was correctly generated. Further there is another
		non-interactive zero-knowledge proof appended which shows that the condition
		@math{y\in{\bf NQR}^\circ_m} holds.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {std::string} sig
		This string contains the self signature of the public key.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {mpz_t} m
		This is the public modulus @math{m = p \cdot q} which is the product
		of two secret primes @math{p} and @math{q}. The size of @math{m}
		is determined by the security parameter @code{TMCG_QRA_SIZE}.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {mpz_t} y
		This is the public quadratic non-residue @math{y\in {\bf NQR}^\circ_m}
		which is used by several zero-knowledge proofs of the toolbox.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {mpz_t} p
		This is the secret prime number @math{p} which is a factor of the
		modulus @math{m}.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {mpz_t} q
		This is the secret prime number @math{q} which is a factor of the
		modulus @math{m}.
	@end deftypecv
	
	@defop {Constructor} TMCG_SecretKey TMCG_SecretKey ()
		This default constructor initializes an empty secret key.
	@end defop
	
	@deftypeop {Constructor} TMCG_SecretKey {} TMCG_SecretKey (@code{const std::string&} n, @code{const std::string&} e, @code{unsigned long int} keysize @code{=TMCG_QRA_SIZE})
		This constructor generates a new secret key where @var{n} is the name or a
		pseudonym of the owner, @var{e} is a corresponding email address, and
		@var{keysize} is the desired bit length of the modulus @math{m}. The
		default value of the last argument is set to @code{TMCG_QRA_SIZE},
		if @var{keysize} is omitted in the call.
	@end deftypeop
	
	@deftypeop {Constructor} TMCG_SecretKey {} TMCG_SecretKey (@code{const std::string&} s)
		This constructor initializes the key from a correctly formated
		input string @var{s}.
	@end deftypeop
	
	@deftypeop {Constructor} TMCG_SecretKey {} TMCG_SecretKey (@code{const TMCG_SecretKey&} that)
		This is a simple copy-constructor and @var{that} is the key to be copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_SecretKey TMCG_SecretKey& = (@code{const TMCG_SecretKey&} that)
		This is a simple assignment-operator and @var{that} is the key to be assigned.
	@end deftypeop
	
	@deftypemethod TMCG_SecretKey bool check ()
		This method tests whether the self signature is valid and whether the
		non-interactive zero-knowledge proofs are sound. It returns @code{true},
		if all checks have been successfully passed. Due to the computational
		complexity of the verification procedure these checks are extremely
		time-consuming.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} fingerprint ()
		This method returns the fingerprint of the key. The fingerprint is the
		hexadecimal notation of the hash value (algorithm @code{TMCG_GCRY_MD_ALGO})
		on the members @code{name}, @code{email}, @code{type}, @code{m}, @code{y},
		@code{nizk}, and @code{sig}.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} selfid ()
		This method returns the real value of the self signature. The string
		@code{ERROR} is returned, if any parse error occurred. The string
		@code{SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG} is returned,
		if the self signature @code{sig} was empty.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} keyid (@code{size_t} size @code{=TMCG_KEYID_SIZE})
		This method returns the unique key identifier of length @var{size}.
		The default value of the first argument is set to @code{TMCG_KEYID_SIZE},
		if @var{size} is omitted in the call.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {size_t} keyid_size (@code{const std::string&} s)
		This method returns the length of the unique key identifier @var{s}.
		Zero is returned, if any parse error occurred.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} sigid (@code{std::string} s)
		This method returns the unique key identifier which is included in the
		signature @var{s}. The string @code{ERROR} is returned, if any parse
		error occurred.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey bool import (@code{std::string} s)
		This method imports the key from a correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey	bool decrypt (@code{char*} value, @code{std::string} s)
		This method decrypts the given encryption packet @var{s} and stores
		the content in @var{value} which is a pointer to a character array
		of size @code{TMCG_SAEP_S0}. The method returns @code{true}, if the
		decryption was successful.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} sign (@code{const std::string&} data)
		This method returns a digital signature on @var{data}.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} encrypt (@code{const char*} value)
		This method encrypts the content of @var{value} which is a pointer to a
		character array of size @code{TMCG_SAEP_S0}. The method returns a
		corresponding encryption packet that can be decrypted by the owner of the
		secret key.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey bool verify (@code{const std::string&} data, @code{std::string} s)
		This method verifies whether the signature @var{s} on @var{data} is valid
		or not. It returns @code{true}, if everything was sound.
	@end deftypemethod
	
	@defop {Destructor} TMCG_SecretKey ~TMCG_SecretKey ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_SecretKey std::ostream& << (@code{std::ostream&} out, @code{const TMCG_SecretKey&} key)
	This operator exports the given @var{key} to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_SecretKey std::istream& >> (@code{std::istream&} in, @code{TMCG_SecretKey&} key)
	This operator imports the given @var{key} from the input stream @var{in}.
	The data has to be delimited by a newline character. The @code{failbit}
	is set, if any parse error occurred.
@end deftypeop

@deftp {Data type} TMCG_PublicKey
	This @code{struct} represents the public part of the TMCG key.
	
	@deftypecv {Member} TMCG_PublicKey {std::string} name
		This string contains the name or a pseudonym of the key owner.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {std::string} email
		This string contains the email address of the key owner.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {std::string} type
		This string contains information about the key type. The common
		prefix is @code{TMCG/RABIN}. It is followed by the decimal encoded
		bit size of the modulus @math{m}. The suffix @code{NIZK} signals
		that the correctness of the key is shown by an appended non-interactive
		zero-knowledge proof. The single parts are separated by underscore
		characters @code{_}, e.g., @code{TMCG/RABIN_1024_NIZK} has the correct
		form.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {std::string} nizk
		This string contains two stages of non-interactive zero-knowledge
		proof of Gennaro, Micciancio and Rabin (ACM CCS, 1998). They show
		that the modulus @math{m} was correctly generated. Further there is another
		non-interactive zero-knowledge proof appended which shows that the condition
		@math{y\in{\bf NQR}^\circ_m} holds.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {std::string} sig
		This string contains the self signature of the public key.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {mpz_t} m
		This is the public modulus @math{m = p \cdot q} which is the product
		of two secret primes @math{p} and @math{q}. The size of @math{m}
		is determined by the security parameter @code{TMCG_QRA_SIZE}.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {mpz_t} y
		This is the public quadratic non-residue @math{y\in {\bf NQR}^\circ_m}
		which is used by several zero-knowledge proofs of the toolbox.
	@end deftypecv
	
	@defop {Constructor} TMCG_PublicKey TMCG_PublicKey ()
		This default constructor initializes an empty public key.
	@end defop
	
	@deftypeop {Constructor} TMCG_PublicKey {} TMCG_PublicKey (@code{const TMCG_SecretKey&} skey)
		This constructor initializes the key using public values
		of the secret key @var{skey}.
	@end deftypeop
	
	@deftypeop {Constructor} TMCG_PublicKey {} TMCG_PublicKey (@code{const TMCG_PublicKey&} pkey)
		This is a simple copy-constructor and @var{pkey} is the key to be copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_PublicKey TMCG_PublicKey& = (@code{const TMCG_PublicKey&} that)
		This is a simple assignment-operator and @var{that} is the key to be assigned.
	@end deftypeop
	
	@deftypemethod TMCG_PublicKey bool check ()
		This method tests whether the self signature is valid and whether the
		non-interactive zero-knowledge proofs are sound. It returns @code{true},
		if all checks have been successfully passed. Due to the computational
		complexity of the verification procedure these checks are extremely
		time-consuming.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} fingerprint ()
		This method returns the fingerprint of the key. The fingerprint is the
		hexadecimal notation of the hash value (algorithm @code{TMCG_GCRY_MD_ALGO})
		on the members @code{name}, @code{email}, @code{type}, @code{m}, @code{y},
		@code{nizk}, and @code{sig}.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} selfid ()
		This method returns the real value of the self signature. The string
		@code{ERROR} is returned, if any parse error occurred. The string
		@code{SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG} is returned,
		if the self signature @code{sig} was empty.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} keyid (@code{size_t} size @code{=TMCG_KEYID_SIZE})
		This method returns the unique key identifier of length @var{size}.
		The default value of the first argument is set to @code{TMCG_KEYID_SIZE},
		if @var{size} is omitted in the call.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {size_t} keyid_size (@code{const std::string&} s)
		This method returns the length of the unique key identifier @var{s}.
		Zero is returned, if any parse error occurred.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} sigid (@code{std::string} s)
		This method returns the unique key identifier which is included in the
		signature @var{s}. The string @code{ERROR} is returned, if any parse
		error occurred.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey bool import (@code{std::string} s)
		This method imports the key from a correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} encrypt (@code{const char*} value)
		This method encrypts the content of @var{value} which is a pointer to a
		character array of size @code{TMCG_SAEP_S0}. The method returns a
		corresponding encryption packet that can be decrypted by the owner of the
		secret key.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey bool verify (@code{const std::string&} data, @code{std::string} s)
		This method verifies whether the signature @var{s} on @var{data} is valid
		or not. It returns @code{true}, if everything was sound.
	@end deftypemethod
	
	@defop {Destructor} TMCG_PublicKey ~TMCG_PublicKey ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_PublicKey std::ostream& << (@code{std::ostream&} out, @code{const TMCG_PublicKey&} key)
	This operator exports the given @var{key} to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_PublicKey std::istream& >> (@code{std::istream&} in, @code{TMCG_PublicKey&} key)
	This operator imports the given @var{key} from the input stream @var{in}.
	The data has to be delimited by a newline character. The @code{failbit}
	is set, if any parse error occurred.
@end deftypeop

@deftp {Data type} TMCG_PublicKeyRing
	This @code{struct} is just a simple container for TMCG public keys. There are
	no particular methods provided by @code{TMCG_PublicKeyRing}. You must use
	the regular interface of the STL container @code{std::vector} to have access
	to the single keys in the ring.
	
	@deftypecv {Member} TMCG_PublicKeyRing {std::vector<TMCG_PublicKey>} keys
		This is the real container that is used to store the keys.
	@end deftypecv
	
	@defop {Constructor} TMCG_PublicKeyRing TMCG_PublicKeyRing ()
		This default constructor initializes an empty public key ring.
	@end defop
	
	@defop {Constructor} TMCG_PublicKeyRing TMCG_PublicKeyRing (@code{size_t} n)
		This constructor initializes the container for storing exactly
		@var{n} keys.
	@end defop
	
	@defop {Destructor} TMCG_PublicKeyRing ~TMCG_PublicKeyRing ()
		This destructor releases all occupied resources.
	@end defop
@end deftp


@subsection Classes
@cindex Classes

@chapter Examples
@cindex Examples
Please have a look at the well-documented examples and test programs in the
directory @file{tests/}, e.g. @file{SchwarzerPeterAlice.cc} and
@file{SchwarzerPeterBob.cc}, respectively.
A detailed exposition with source code fragments will later be included here.


@c **********************************************************
@c *******************  Appendices  *************************
@c **********************************************************
@include gpl.texi
@include fdl.texi

@unnumbered General Index
@printindex cp

@unnumbered API Index
@printindex fn

@bye
