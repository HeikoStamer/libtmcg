\input texinfo
@c %**start of header
@documentencoding ISO-8859-1
@setfilename libTMCG.info
@include version.texi
@settitle The LibTMCG Reference Manual
@c %**end of header

@c Include data type index into function index
@syncodeindex tp fn

@c A simple macro for optional variables. (copied from gcrypt manual)
@macro ovar{varname}
@r{[}@var{\varname\}@r{]}
@end macro

@copying
This is the reference manual of LibTMCG.

Revision $Id: libTMCG.texi,v 1.25 2006/04/02 19:51:34 stamer Exp $.

Copyright @copyright{} 2005, 2006 Heiko Stamer <@email{stamer@@gaos.org}>.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts. A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end quotation
@end copying

@titlepage
@title The LibTMCG Reference Manual
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Heiko Stamer <@email{stamer@@gaos.org}>

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top LibTMCG Reference Manual

@insertcopying
@end ifnottex

@c **********************************************************
@c *******************  Introduction  ***********************
@c **********************************************************
@chapter Introduction
`@acronym{LibTMCG}' is a general purpose C++ library for
creating secure electronic card games. The most remarkable
feature is the absence of a trusted third party (TTP), i.e.,
neither a central game server nor trusted hardware components
are necessary. To emphasize this point again: With the present
library there is no need for an independent referee, because
the applied protocols provide a basic level of confidentiality
and fairness by itself. Of course, we cannot avoid that
malicious players share information about their private
cards, but the protocols ensure that the shuffle of the
deck is performed randomly (presumed that at least one
player is honest) and thus the cards will be distributed
uniformly among the players. Further, no coalition can
learn the private cards of a player against his will (except
for trivial conclusions). The corresponding cryptographic
problem, actually called ''Mental Poker'', has been studied
since 1979 (Shamir, Rivest, and Adleman) by many authors.

Our implementation relies on advanced cryptographic
techniques---the so-called zero-knowledge proofs. Using
these `building blocks' the high-level protocols minimize
the effect of coalitions and preserve the confidentiality
of the players' strategy, i.e., the players are not required
to reveal their cards at the end of the game to show that
they did not cheat.

LibTMCG is @emph{Free Software} according to the definition
of the @uref{http://www.fsf.org/licensing/essays/free-sw.html,,
Free Software Foundation}. The source code is released under
the GNU @emph{General Public License} Version 2.

@c **********************************************************
@section Further Reading
The cryptographic background and a detailed discussion of
the implementation issues are beyond the scope of this manual.
The interested reader is referred to the following papers:
@quotation [Sc98]
	@sc{Christian Schindelhauer}.
	@emph{Toolbox for Mental Card Games.}@*
	Technical Report A-98-14, University of L@"ubeck, 1998.
@end quotation
@quotation [BS03]
	@sc{Adam Barnett} and @sc{Nigel P. Smart}.
	@emph{Mental Poker Revisited.}@*
	In K.G. Paterson (Ed.): Cryptography and Coding 2003,
	Lecture Notes in Computer Science 2898, pp. 370--383, 2003.
@end quotation
@quotation [Gr05]
	@sc{Jens Groth}.
	@emph{A Verifiable Secret Shuffle of Homomorphic Encryptions.}@*
	Cryptology ePrint Archive, Report 2005/246, 2005.
@end quotation
@quotation [St04]
	@sc{Heiko Stamer}.
	@emph{Kryptographische Skatrunde.} (in German)@*
	Offene Systeme (ISSN 1619-0114), 4:10--30, 2004.@*
	@uref{http://www.gaos.org/@/~stamer/@/OS-4-2004-openskat_rev2005.pdf}
@end quotation
@quotation [St05]
	@sc{Heiko Stamer}.
	@emph{Efficient Electronic Gambling: An Extended Implementation
	of the Toolbox for Mental Card Games.}@*
	Proceedings of the Western European Workshop on Research in
	Cryptology (WEWoRC 2005), Lecture Notes in Informatics P-74,
	pp. 1--12, 2005.
@end quotation

@c **********************************************************
@section Getting Started
This manual describes the application programming interface
of LibTMCG. All relevant data types, public classes and
security parameters are explained. The reader should have
an advanced knowledge in applied cryptography and C++
programming. Reference is made at this point to the famous
@cite{Handbook of Applied Cryptography} for a brief
introduction.

This document follows, in style and rarely in phrasing,
the @cite{Reference Manual of the GNU Crypto Library}.
Thus don't be surprised, if you recognize some obvious
analogies.

@c **********************************************************
@section Preparation
LibTMCG depends on the three other basic libraries. Therefore
you need the corresponding development files to build LibTMCG
and your application properly:
@itemize @bullet
	@item GNU Multiple Precision Arithmetic Library (@file{libgmp}),
		Version @math{\ge} 4.1.0
		
		This library provides a powerful framework for performing
		arbitrary precision arithmetic on integers. Further reasons
		for choosing this dependency are the license compatibility,
		portability, vital maintenance, and, of course, the
		reasonable performance.
		
	@item GNU Crypto Library (@file{libgcrypt}),
		Version @math{\ge} 1.2.0
		
		This library provides some basic cryptographic algorithms
		(e.g. RIPEMD-160) and an easily usable interface to obtain
		cryptographically strong pseudo random numbers.
	
	@item GNU Privacy Guard Error Code Library (@file{libgpg-error}),
		Version @math{\ge} 0.5
		
		This library defines common error values, e.g., returned by the
		GNU Crypto Library.
@end itemize
We suppose that the reader is familiar with these libraries
because their correct installation and configuration is
crucial to the security of the entire application.

@c **********************************************************
@section Header Files and Name Spaces
@cindex Header Files
@cindex Name Spaces
The interface definitions of the classes and the security
parameters@footnote{These parameters are fixed at compile time.
Please don't change anything unless you know exactly what you are
doing, and what the dangers are! Beside the apparent security
concerns you will probably break the compatibility with other
LibTMCG applications.} are provided by the central header file
@file{libTMCG.hh}. You have to include this file in all of your
sources, either directly or through some other file.

@example
#include <libTMCG.hh>
@end example

There are no uniform C++ name spaces for the most parts of the
library. Some classes have the common prefix @code{TMCG_*} or
@code{VTMF_*} while others are composed of the author names
and the title abbreviation of the related research paper.
Further there are internally
used C functions which might produce conflicting names. These
function names are prepended by @code{mpz_*} because they are
extensions for the large integer support of the GNU Multiple
Precision Arithmetic Library.

@c **********************************************************
@section Building Sources
If you want to compile a source file including the @file{libTMCG.hh}
header file, you must make sure that the compiler can find it in the
directory hierarchy. This is accomplished by adding the path of the
corresponding directory to the compilers include file search path
(via the @option{-I} option).

However, the path to the include file is determined at the time the
source is configured. To solve this problem, LibTMCG ships with a small
helper program @command{libTMCG-config} that knows the path to the
include file and a few other configuration options. The options that
need to be added to the compiler invocation are output by the
@option{--cflags} option to @command{libTMCG-config}. The following
example shows how it can be used at the command line:

@example
g++ -c foo.cc `libTMCG-config --cflags`
@end example

Adding the output of @samp{libTMCG-config --cflags} to the compilers
command line will ensure that the compiler can find the library header
file.

A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files. For this to work,
the path to the library files has to be added to the library search
path (via the @option{-L} option). For this, the option @option{--libs}
of @command{libTMCG-config} can be used. For convenience, this option
also outputs all other options that are required to link the program
with the library (in particular, the @samp{-lTMCG} option). The example
shows how to link @file{foo.o} with LibTMCG to a program called
@command{foo}.

@example
g++ -o foo foo.o `libTMCG-config --libs`
@end example

Of course you can also combine both examples to a single command by
specifying both options to @command{libTMCG-config}:

@example
g++ -o foo foo.c `libTMCG-config --cflags --libs`
@end example

@c **********************************************************
@section Building Sources Using GNU Automake
You can use GNU Automake to obtain automatically generated
Makefiles. If you do that you do not have to worry about finding and
invoking the @command{libTMCG-config} script at all.
LibTMCG provides an Automake extension that does all the work for you.

@defmac AM_PATH_LIBTMCG (@ovar{minimum-version}, @ovar{action-if-found}, @ovar{action-if-not-found})
Check whether LibTMCG (at least version @var{minimum-version}, if given)
exists on the host system. If it is found, execute @var{action-if-found},
otherwise do @var{action-if-not-found}.

Additionally, the function defines @code{LIBTMCG_CFLAGS} to the
flags needed for compilation of the program to find the necessary header
files, and @code{LIBTMCG_LIBS} to the linker flags needed to link the
program with the library.
@end defmac

You can use the defined variables in @file{Makefile.am} like below:

@example
AM_CPPFLAGS = $(LIBTMCG_CFLAGS)
LDADD = $(LIBTMCG_LIBS)
@end example

@c **********************************************************
@section Initializing the Library
The first step is the initialization of LibTMCG. The following
function must be invoked early in your program, i.e., before
you make use of any other capability of LibTMCG.

@deftypefun bool init_libTMCG ()
The function checks whether the installed third-party libraries
match their required versions. Further it initialize them
and returns @code{true}, if everything was sound. Otherwise
@code{false} is returned and an appropriate error message
is sent to @code{stderr}.
@end deftypefun

@c **********************************************************
@c *************************  API  **************************
@c **********************************************************
@chapter Application Programming Interface

@c **********************************************************
@section Preliminaries
The most card games are played with a regular card deck, i.e.,
cards where the pattern on the picture side determines the card
type (e.g. the King of Spades) and where the reverse sides of
all cards are indistinguishable.

An @emph{open card} is TODO

@c **********************************************************
@section Preprocessor Defined Global Symbols
@cindex Security Parameters
Please note that the following macros are fixed at compile
time of LibTMCG and cannot be changed by your application.
They are only provided here for informational purposes.

@defmac TMCG_MR_ITERATIONS
	Defines the number of iterations for the Miller-Rabin primality test.
	The default value is @code{64L} which implies a soundness error
	probability @math{{} \le 4^{-64}}.
@end defmac

@defmac TMCG_GROTH_L_E
	Defines the security parameter @math{\ell_e} of Groth's interactive
	shuffle argument@tie{}[Gr05]. The default value is @code{80L} which
	implies a soundness error probability @math{{} \le 2^{-80}}. For the
	intended purpose of LibTMCG this bound seems to be reasonable small
	enough.
@end defmac

@defmac TMCG_DDH_SIZE
Defines the security parameter (field size in bit) of the DDH-hard
group @math{G} which is used by the card encoding scheme of Barnett
and Smart@tie{}[BS03]. The underlying assumptions are DDH, CDH, and DLOG.
The default value is @code{1024L}.
@end defmac

@defmac TMCG_DLSE_SIZE
Defines the security parameter (subgroup size in bit) of the group
@math{G} which is used by the card encoding scheme of Barnett and
Smart@tie{}[BS03]. The underlying assumptions are DLSE (related to DDH)
and DLOG. The default value is @code{160L}.
@end defmac

@defmac TMCG_GCRY_MD_ALGO
Defines the message digest algorithm for digital signatures and
the Fiat-Shamir heuristic. The security of the most non-interactive
zero-knowledge proofs (NIZK) is proved in the so-called random
oracle model, i.e., one supposes that the used hash function behaves
like an ideal random function (which cannot exist in a real world scenario).
However, this assumption seems to be reasonable, if the hash function
is carefully implemented.
The default value is @code{GCRY_MD_RMD160}. This constant (from the
GNU Crypto Library) represents the hash algorithm RIPEMD-160 which has
an output length of 160 bit. Thus it leads to a security level of
approximately @math{2^{80}}, assuming that a birthday-attack is the
best known attack against this algorithm.
@end defmac

@defmac TMCG_KEYID_SIZE
Defines the length (in characters w.r.t. @code{TMCG_MPZ_IO_BASE})
of the distinctive suffix for the unique key identifier. The default
value is @code{8} which spans a reasonable name space for at least
@math{2^{20}} different keys.

Each key identifier starts with the string @code{ID} followed by
the decimal coded value @code{TMCG_KEYID_SIZE} and an appended
carret symbol @code{^}. The final suffix consists of number
@code{TMCG_KEYID_SIZE} alphanumerical characters of the self signature.
This suffix has enough entropy included to be used as unique key
identifier.
@end defmac

@defmac TMCG_KEY_NIZK_STAGE1
Defines the security parameter (number of iterations) of the NIZK
proof (stage 1) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{16} which implies
a soundness error probability @math{{} \le d^{-16}}, where
@math{d = {\rm gcd}(m, \phi(m))}. This parameter is only relevant for the
card encoding scheme of Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_KEY_NIZK_STAGE2
Defines the security parameter (number of iterations) of the NIZK
proof (stage 2) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{128} which implies
a soundness error probability @math{{} \le 2^{-128}}.
This parameter is only relevant for the card encoding scheme of
Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_KEY_NIZK_STAGE3
Defines the security parameter (number of iterations) of the NIZK
proof (stage 3) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{128} which implies
a soundness error probability @math{{} \le 2^{-128}}.
This parameter is only relevant for the card encoding scheme of
Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_LIBGCRYPT_VERSION
Defines the necessary minimum version of the GNU Crypto Library.
The default value is @code{"1.2.0"}. During the initialization of
LibTMCG it is checked whether the version number of the currently
available shared object is greater or equal.
@end defmac

@defmac TMCG_LIBGMP_VERSION
Defines the necessary minimum version of the GNU Multiple Precision
Arithmetic Library. The default value is @code{"4.1.0"}. During the
initialization of LibTMCG it is checked whether the version number of
the header file used at compile time is greater or equal.
@end defmac

@defmac TMCG_MAX_CARDS
Defines the maximum number of stackable cards.
The default value is @code{128L}.
@end defmac

@defmac TMCG_MAX_PLAYERS
Defines the maximum number of participating players in the scheme of
Schindelhauer@tie{}[Sc98]. The default value is @code{32L}.
@end defmac

@defmac TMCG_MAX_TYPEBITS
Defines the maximum number of bits to represent the card type in the
scheme of Schindelhauer@tie{}[Sc98]. Further, this value determines
the maximum size of the message space for the scheme of Barnett and
Smart@tie{}[BS03]. The default value @code{8L} implies that 256
different card types are possible.
@end defmac

@defmac TMCG_MPZ_IO_BASE
Defines the input/output encoding base of the @code{iostream} operators
for arbitrary precision integers. The default value @code{36L} is currently
the largest base supported by the GNU Multiple Precision Arithmetic Library.
@end defmac

@defmac TMCG_PRAB_K0
Defines the security parameter @math{k_0} (in characters) for the PRab
digital signature scheme of Bellare and Rogaway. The default value is
@code{20} which leads to a security level of approximately @math{2^{80}}.
@end defmac

@defmac TMCG_QRA_SIZE
Defines the security parameter (size of the modulus @math{m = p \cdot q}
in bit) of the TMCG key. The underlying assumptions are QRA and FACTOR.
The default value is @code{1024L}. This parameter is only relevant
for the card encoding scheme of Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_SAEP_S0
Defines the security parameter @math{s_0} (in characters) for the Rabin-SAEP
encryption scheme of Boneh. The default value @code{20} implies a security
around @math{2^{80}} against @acronym{CCA, Chosen Ciphertext Attacks}.
@end defmac

@defmac TMCG_HASH_COMMITMENT
Defines whether or not shortened commitments are used by the shuffle
proof of Schindelhauer@tie{}[Sc98]. The default value is @code{true},
because it decreases the communication complexity enormously. However,
as a consequence the soundness property of the proof only remains valid
in the random oracle model.
@end defmac

@defmac TMCG_MAX_FPOWM_T
Defines the maximum size of a possible exponent (in bit) used with the
fast exponentiation procedures based on precomputed tables.
The default value is @code{2048}.
@end defmac

@c **********************************************************
@section Public Data Types and Classes
This section describes the important data types and classes
that are necessary to create a secure card game. Private methods
and internally used members are not explained.

@subsection Data Types
@cindex Data Types
LibTMCG provides data types for playing cards, for stacks, and for
cryptographic keys.

@subsubsection Encoding Schemes for Cards
@cindex Card Encoding Schemes
There are two different encoding schemes that can be used
for the digital representation of playing cards. In the
scheme of Schindelhauer@tie{}[Sc98] the type of a card is
shared among the players through bit-wise representation
by quadratic (non-)residues. Thus the security relies on
the well-known @acronym{QRA, Quadratic Residuosity Assumption}.
Unfortunately, the size of a card grows linearly in the
number of players and logarithmically in the number of
different card types. Recently the much more efficient
solution of Barnett and Smart@tie{}[BS03] has been
implemented. This encoding works on a cyclic group of
prime order and requires that the @acronym{DDH, Decisional
Diffie-Hellman Assumption} holds there.

For both schemes there is a data type with the suffix
@code{Card} which represents an open or even a masked card.
Further, there is corresponding data type with the suffix
@code{CardSecret} that represents the secret values involved
in a card masking operation.

Because of the reduced computational and communication
complexity (cf.@tie{}[St05]) the usage of the second card
encoding scheme, i.e. @code{VTMF_Card}, is highly recommended.

@deftp {Data type} TMCG_Card
	This @code{struct} represents a card in the encoding scheme
	of Schindelhauer@tie{}[Sc98]. The type of the card is shared
	among the players by quadratic residues and non-residues,
	respectively. Thus the security relies on the Quadratic
	Residuosity Assumption.
	
	@deftypecv {Member} TMCG_Card {std::vector< std::vector<MP_INT> >} z
		This @math{k\times w}-matrix encodes the type of the
		corresponding card in a shared way. For each of the
		@math{k} players there is a separate row and for each of
		the @math{w} bits in the binary representation of the
		type there is a column. The elements are numbers from
		the group @math{{\bf Z}^{\circ}_{m_i}} where @math{m_i}
		is the public modulus of the @math{i}th player.
	@end deftypecv
	
	@defop {Constructor} TMCG_Card TMCG_Card ()
		This default constructor initializes the card with an empty
		@math{1\times 1}-matrix. Later the method
		@code{TMCG_Card::resize} can be used to enlarge the
		card representation.
	@end defop
	
	@defop {Constructor} TMCG_Card TMCG_Card (@code{size_t} k, @code{size_t} w)
		This constructor initializes the card with an empty
		@math{k\times w}-matrix. The parameter @var{k} is the
		number of players and @var{w} is the maximum number
		of bits used by the binary representation of the card
		type.
	@end defop
	
	@deftypeop {Constructor} TMCG_Card {} TMCG_Card (@code{const TMCG_Card&} that)
		This is a simple copy-constructor and @var{that} is the card to be
		copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Card TMCG_Card& = (@code{const TMCG_Card&} that)
		This is a simple assignment-operator and @var{that} is the card to
		be assigned.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Card bool == (@code{const TMCG_Card&} that)
		This operator tests two card representations for equality.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Card bool != (@code{const TMCG_Card&} that)
		This operator tests two card representations for inequality.
	@end deftypeop
	
	@deftypemethod TMCG_Card void resize (@code{size_t} k, @code{size_t} w)
		This method resizes the representation of the card.
		The current content of the member @code{z} will be
		released and a new @math{k\times w}-matrix is created.
		The parameter @var{k} is the number of players and
		@var{w} is the maximum number of bits used by the binary
		representation of the card type.
	@end deftypemethod
	
	@deftypemethod TMCG_Card bool import (@code{std::string} s)
		This method imports the content of the member @code{z} from
		the correctly formated input string @var{s}. It returns
		@code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_Card ~TMCG_Card ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_Card std::ostream& << (@code{std::ostream&} out, @code{const TMCG_Card&} card)
	This operator exports the content of the member @code{z}
	(of the given @code{TMCG_Card} @var{card}) to the output
	stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_Card std::istream& >> (@code{std::istream&} in, @code{TMCG_Card&} card)
	This operator imports the content of the member @code{z}
	(of the given @code{TMCG_Card} @var{card}) from the input
	stream @var{in}. The data has to be delimited by a newline
	character. The @code{failbit} of the stream is set, if any
	parse error occurred.
@end deftypeop

@deftp {Data type} TMCG_CardSecret
	This @code{struct} represents the secret used for a card masking
	operation in the original encoding scheme of Schindelhauer@tie{}[Sc98].
	
	@deftypecv {Member} TMCG_CardSecret {std::vector< std::vector<MP_INT> >} r
		This @math{k\times w}-matrix encodes the first part of the
		secret. For each of the @math{k} players there is a separate
		row and for each of the @math{w} bits in the binary representation
		of the corresponding card type there is a column. The elements are
		numbers from the group @math{{\bf Z}^{\circ}_{m_i}} where @math{m_i}
		is the public modulus of the @math{i}th player.
	@end deftypecv
	
	@deftypecv {Member} TMCG_CardSecret {std::vector< std::vector<MP_INT> >} b
		This @math{k\times w}-matrix encodes the second part of the
		secret. For each of the @math{k} players there is a separate
		row and for each of the @math{w} bits in the binary representation
		of the corresponding card type there is a column. The elements are
		simply numbers from @math{\{0, 1\}}.
	@end deftypecv
	
	@defop {Constructor} TMCG_CardSecret TMCG_CardSecret ()
		This default constructor initializes both members with an empty
		@math{1\times 1}-matrix. Later the method
		@code{TMCG_CardSecret::resize} can be used to enlarge the
		card representation.
	@end defop
	
	@defop {Constructor} TMCG_CardSecret TMCG_CardSecret (@code{size_t} k, @code{size_t} w)
		This constructor initializes both members with an empty
		@math{k\times w}-matrix. The parameter @var{k} is the
		number of players and @var{w} is the maximum number
		of bits used by the binary representation of the
		corresponding card type.
	@end defop
	
	@deftypeop {Constructor} TMCG_CardSecret {} TMCG_CardSecret (@code{const TMCG_CardSecret&} that)
		This is a simple copy-constructor and @var{that} is the secret to be
		copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_CardSecret TMCG_CardSecret& = (@code{const TMCG_CardSecret&} that)
		This is a simple assignment-operator and @var{that} is the secret to
		be assigned.
	@end deftypeop
	
	@deftypemethod TMCG_CardSecret void resize (@code{size_t} k, @code{size_t} w)
		This method resizes the representation of the secret.
		The current content of the members @code{r} and @code{b}
		will be released and new @math{k\times w}-matrices are
		created. The parameter @var{k} is the number of players and
		@var{w} is the maximum number of bits used by the binary
		representation of the corresponding card type.
	@end deftypemethod
	
	@deftypemethod TMCG_CardSecret bool import (@code{std::string} s)
		This method imports the content of the members @code{r} and
		@code{b} from the correctly formated input string @var{s}.
		It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_CardSecret ~TMCG_CardSecret ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_CardSecret std::ostream& << (@code{std::ostream&} out, @code{const TMCG_CardSecret&} cardsecret)
	This operator exports the content of the members @code{r}
	and @code{b} (of the given @code{TMCG_CardSecret}
	@var{cardsecret}) to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_CardSecret std::istream& >> (@code{std::istream&} in, @code{TMCG_CardSecret&} cardsecret)
	This operator imports the content of the members @code{r}
	and @code{b} (of the given @code{TMCG_CardSecret}
	@var{cardsecret}) from the input stream @var{in}.
	The data has to be delimited by a newline character.
	The @code{failbit} of the stream is set, if any parse error
	occurred.
@end deftypeop

@deftp {Data type} VTMF_Card
	This @code{struct} represents a card in the encoding scheme
	of Barnett and Smart@tie{}[BS03]. Here we use the discrete logarithm
	based instantiation of their general cryptographic primitive
	@acronym{VTMF, Verifiable @var{k}-out-of-@var{k} Threshold Masking
	Function}. The security relies on the DDH assumption in the
	underlying abelian group @math{G}.
	
	@deftypecv {Member} VTMF_Card {mpz_t} c_1
		This is the first part of the encrypted card type.
		It is an element from the underlying group @math{G}.
	@end deftypecv
	
	@deftypecv {Member} VTMF_Card {mpz_t} c_2
		This is the second part of the encrypted card type.
		It is also an element from the underlying group @math{G}.
	@end deftypecv
	
	@defop {Constructor} VTMF_Card VTMF_Card ()
		This default constructor initializes an empty card where
		the members @code{c_1} and @code{c_2} are set to zero.
	@end defop
	
	@deftypeop {Constructor} VTMF_Card {} VTMF_Card (@code{const VTMF_Card&} that)
		This is a simple copy-constructor and @var{that} is the
		card to be copied.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_Card VTMF_Card& = (@code{const VTMF_Card&} that)
		This is a simple assignment-operator and @var{that} is
		the card to be assigned.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_Card bool == (@code{const VTMF_Card&} that)
		This operator tests two card representations for equality.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_Card bool != (@code{const VTMF_Card&} that)
		This operator tests two card representations for inequality.
	@end deftypeop
	
	@deftypemethod VTMF_Card bool import (@code{std::string} s)
		This method imports the content of the members @code{c_1}
		and @code{c_2} from a correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} VTMF_Card ~VTMF_Card ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} VTMF_Card std::ostream& << (@code{std::ostream&} out, @code{const VTMF_Card&} card)
	This operator exports the content of the members @code{c_1}
	and @code{c_2} (of the given @code{VTMF_Card} @var{card})
	to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} VTMF_Card std::istream& >> (@code{std::istream&} in, @code{VTMF_Card&} card)
	This operator imports the content of the members @code{c_1}
	and @code{c_2} (of the given @code{VTMF_Card} @var{card})
	from the input stream @var{in}. The data has to be delimited
	by a newline character. The @code{failbit} of the stream is
	set, if any parse error occurred.
@end deftypeop

@deftp {Data type} VTMF_CardSecret
	This @code{struct} represents the secrets used in the card masking
	operation by the encoding scheme of Barnett and Smart@tie{}[BS03].
	
	@deftypecv {Member} VTMF_CardSecret {mpz_t} r
		This member is the exponent (randomizer) used in the masking operation.
		It should be chosen uniformly and randomly from @math{{\bf Z}_q}
		where @math{q} is the order of the finite abelian group @math{G}
		for which the DDH assumption holds.
		
		According to the results of Koshiba and Kurosawa (see @emph{Short Exponent
		Diffie-Hellman Problems}, PKC@tie{}2004, LNCS@tie{}2947) the length of
		this exponent can be shorten to a more efficient size (e.g. 160@tie{}bit),
		if the corresponding generator of @math{G} is adjusted as well. Under the
		additional @acronym{DLSE, Discrete Logarithm with Short Exponents}
		assumption the DDH problem in @math{G} seems to be still hard.
		By such an optimization trick we gain a great performance advantage for
		almost all modular exponentiations that are computed during the masking
		operation, if the VTMF primitive was instatiated by the later explained
		class @code{BarnettSmartVTMF_dlog_GroupQR}. Furthermore, the size of the
		card secret is substantially reduced which results in an improved
		communication complexity.
	@end deftypecv
	
	@defop {Constructor} VTMF_CardSecret VTMF_CardSecret ()
		This default constructor initializes the secret with an
		empty member @code{r}.
	@end defop
	
	@deftypeop {Constructor} VTMF_CardSecret {} VTMF_CardSecret (@code{const VTMF_CardSecret&} that)
		This is a simple copy-constructor and @var{that} is the secret to be
		copied.
	@end deftypeop
	
	@deftypeop {Operator} VTMF_CardSecret VTMF_CardSecret& = (@code{const VTMF_CardSecret&} that)
		This is a simple assignment-operator and @var{that} is the secret to
		be assigned.
	@end deftypeop
	
	@deftypemethod VTMF_CardSecret bool import (@code{std::string} s)
		This method imports the content of the member @code{r}
		from the correctly formated input string @var{s}.
		It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} VTMF_CardSecret ~VTMF_CardSecret ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} VTMF_CardSecret std::ostream& << (@code{std::ostream&} out, @code{const VTMF_CardSecret&} cardsecret)
	This operator exports the content of the member @code{r}
	(of the given @code{VTMF_CardSecret} @var{cardsecret})
	to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} VTMF_CardSecret std::istream& >> (@code{std::istream&} in, @code{VTMF_CardSecret&} cardsecret)
	This operator imports the content of the member @code{r}
	(of the given @code{VTMF_CardSecret} @var{cardsecret})
	from the input stream @var{in}. The data has to be
	delimited by a newline character. The @code{failbit} of
	the stream is set, if any parse error occurred.
@end deftypeop

@subsubsection Stacks
@cindex Stacks
All of the following data types are generic containers that can be
instantiated as C++ templates with the former explained @code{Card}
and @code{CardSecret} data types, respectively.

@deftp {Data type} TMCG_Stack<@var{CardType}>
	This @code{struct} is a simple container for cards of the specified
	@code{@var{CardType}}. Currently, the elements can be either of type
	@code{TMCG_Card} or @code{VTMF_Card} depending on which kind of encoding
	scheme is used. The @code{TMCG_Stack} structure is mainly used to represent
	a stack of masked cards, i.e., playing cards that are stacked in a face-down
	manner. It can be either a public stack where all participants have access to
	or even a private stack, e.g. the players' hand. If the corresponding
	card types are known it can also serve as an ``open stack'', although
	@code{TMCG_OpenStack} is more suitable in that case.
	
	@deftypecv {Member} TMCG_Stack {std::vector<@var{CardType}>} stack
		This is the container that is used internally for storing the cards.
	@end deftypecv
	
	@defop {Constructor} TMCG_Stack TMCG_Stack ()
		This default constructor initializes an empty stack.
	@end defop
	
	@deftypeop {Operator} TMCG_Stack TMCG_Stack& = (@code{const TMCG_Stack<@var{CardType}>&} that)
		This is a simple assignment-operator and @var{that} is the stack to
		be assigned.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Stack bool == (@code{const TMCG_Stack<@var{CardType}>&} that)
		This operator tests two stacks for equality. It checks whether the
		sizes of the stacks and the contained cards are equal with respect to
		the implied order.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Stack bool != (@code{const TMCG_Stack<@var{CardType}>&} that)
		This operator tests two stacks for inequality. It returns @code{true}, if
		either the sizes does not match or at least two corresponding cards are
		not equal.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Stack {const @var{CardType}&} [] (@code{size_t} n)
		This operator provides read-only random access to the contained cards.
		It returns a const-reference to the @var{n}th card from the top of the stack.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_Stack {@var{CardType}&} [] (@code{size_t} n)
		This operator provides random access to the contained cards.
		It returns a reference to the @var{n}th card from the top of the stack.
	@end deftypeop
	
	@deftypemethod TMCG_Stack size_t size ()
		This method returns the size of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack void push (@code{const @var{CardType}&} c)
		This method pushes the card @var{c} to the back of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack void push (@code{const TMCG_Stack<@var{CardType}>&} s)
		This method pushes the stack @var{s} to the back of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack void push (@code{const TMCG_OpenStack<@var{CardType}>&} s)
		This method pushes the cards of the open stack @var{s} to the back
		of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool empty ()
		This method returns @code{true}, if the stack is empty.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool pop (@code{@var{CardType}&} c)
		This method removes a card from the back and stores the data in @var{c}.
		It returns @code{true}, if the stack was not empty and thus @var{c}
		contains useful data.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack void clear ()
		This method clears the stack, i.e., it removes all cards.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool find (@code{const @var{CardType}&} c)
		This method returns @code{true}, if the card @var{c} was found in the
		stack.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool remove (@code{const @var{CardType}&} c)
		This method removes the top-most card from the stack which is equal to
		@var{c}. It returns @code{true}, if the card was found and successfully
		removed.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack size_t removeAll (@code{const @var{CardType}&} c)
		This method removes every card from the stack which is equal to @var{c}.
		It returns the number of removed cards.
	@end deftypemethod
	
	@deftypemethod TMCG_Stack bool import (@code{std::string} s)
		This method imports the stack from the correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_Stack ~TMCG_Stack ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_Stack std::ostream& << (@code{std::ostream&} out, @code{const TMCG_Stack<@var{CardType}>&} stack)
	This operator exports the given @var{stack} to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_Stack std::istream& >> (@code{std::istream&} in, @code{TMCG_Stack<@var{CardType}>&} stack)
	This operator imports the given @var{stack} from the input stream @var{in}.
	The data has to be delimited by a newline character. The @code{failbit} of
	the stream is set, if any parse error occurred.
@end deftypeop

@deftp {Data type} TMCG_OpenStack<@var{CardType}>
	This @code{struct} is a simple container for cards of the specified
	@code{@var{CardType}} whose types are known. The elements are pairs where
	the first component is the type and the second component is the corresponding
	card. The card type is represented by a @code{size_t} integer. Currently, the
	cards can be either of type @code{TMCG_Card} or @code{VTMF_Card} depending on
	which kind of encoding scheme is used.
	
	@deftypecv {Member} TMCG_OpenStack {std::vector<std::pair<size_t, @var{CardType}> >} stack
		This is the container that is used internally for storing the pairs.
	@end deftypecv
	
	@defop {Constructor} TMCG_OpenStack TMCG_OpenStack ()
		This default constructor initializes an empty stack.
	@end defop
	
	@deftypeop {Operator} TMCG_OpenStack TMCG_OpenStack& = (@code{const TMCG_OpenStack<@var{CardType}>&} that)
		This is a simple assignment-operator and @var{that} is the stack to
		be assigned.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_OpenStack bool == (@code{const TMCG_OpenStack<@var{CardType}>&} that)
		This operator tests two stacks for equality. It checks whether the types,
		the sizes, and the contained cards are equal with respect to the stack order.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_OpenStack bool != (@code{const TMCG_OpenStack<@var{CardType}>&} that)
		This operator tests two stacks for inequality. It returns @code{true}, if
		either the sizes resp. types does not match or at least two corresponding cards
		are not equal.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_OpenStack {const std::pair<size_t, @var{CardType}>&} [] (@code{size_t} n)
		This operator provides read-only random access to the contained pairs.
		It returns a const-reference to the @var{n}th pair from the top of the stack.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_OpenStack {std::pair<size_t, @var{CardType}>&} [] (@code{size_t} n)
		This operator provides random access to the contained pairs.
		It returns a reference to the @var{n}th pair from the top of the stack.
	@end deftypeop
	
	@deftypemethod TMCG_OpenStack size_t size ()
		This method returns the size of the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack void push (@code{const std::pair<size_t, @var{CardType}>&} p)
		This method pushes the pair @var{p} to the back of the stack. The first
		component is the type and the second component is the corresponding card
		representation.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack void push (@code{size_t} type, @code{const @var{CardType}&} c)
		This method pushes a pair to the back of the stack. The parameter @var{type}
		is the card type and @var{c} is the corresponding card representation.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack void push (@code{const TMCG_OpenStack<@var{CardType}>&} s)
		This method pushes the pairs of the stack @var{s} to the back
		of this stack.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool empty ()
		This method returns @code{true}, if the stack is empty.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool pop (@code{size_t&} type, @code{@var{CardType}&} c)
		This method removes a pair from the back of the stack. It stores the card type
		in @var{type} and the	representation in @var{c}. It returns @code{true}, if the stack
		was not empty and thus @var{type} and @var{c} contain useful data.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack void clear ()
		This method clears the stack, i.e., it removes all pairs.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool find (@code{size_t} type)
		This method returns @code{true}, if a pair with the first component @var{type} was
		found in the stack.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool remove (@code{size_t} type)
		This method removes the top-most pair with the first component @var{type} from the
		stack. It returns @code{true}, if such a pair was found and successfully removed.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack size_t removeAll (@code{size_t} type)
		This method removes every pair from the stack whose first component is equal to
		@var{type}. Further it returns the number of removed pairs.
	@end deftypemethod
	
	@deftypemethod TMCG_OpenStack bool move (@code{size_t} type, @code{TMCG_Stack<@var{CardType}>&} s)
	This method moves the top-most card representation of the given @var{type} to another
	stack @var{s}. It returns @code{true}, if such a pair was found and successfully moved.
	@end deftypemethod
	
	@defop {Destructor} TMCG_OpenStack ~TMCG_OpenStack ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftp {Data type} TMCG_StackSecret<@var{CardSecretType}>
	This @code{struct} is a simple container for the secrets involved
	in the masking operation of cards. Additionally, the permutation
	of a corresponding shuffle of the stack is stored.
	The elements are pairs where the first component is a permutation
	index of type @code{size_t} and the second component is a card
	secret of the specified @code{@var{CardSecretType}}. Currently,
	such secrets can be either of type @code{TMCG_CardSecret} or
	@code{VTMF_CardSecret} depending on which kind of encoding scheme
	is used.
	
	@deftypecv {Member} TMCG_StackSecret {std::vector<std::pair<size_t, @var{CardSecretType}> >} stack
		This is the container that is used internally for storing the pairs.
	@end deftypecv
	
	@defop {Constructor} TMCG_StackSecret TMCG_StackSecret ()
		This default constructor initializes an empty stack secret.
	@end defop
	
	@deftypeop {Operator} TMCG_StackSecret TMCG_StackSecret& = (@code{const TMCG_StackSecret<@var{CardSecretType}>&} that)
		This is a simple assignment-operator and @var{that} is the
		stack secret to be assigned.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_StackSecret {const std::pair<size_t, @var{CardSecretType}>&} [] (@code{size_t} n)
		This operator provides read-only random access to the contained pairs.
		It returns a const-reference to the @var{n}th pair from the top of the stack secret.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_StackSecret {std::pair<size_t, @var{CardSecretType}>&} [] (@code{size_t} n)
		This operator provides random access to the contained pairs.
		It returns a reference to the @var{n}th pair from the top of the stack secret.
	@end deftypeop
	
	@deftypemethod TMCG_StackSecret size_t size ()
		This method returns the size of the stack secret.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret void push (@code{size_t} index, @code{const @var{CardSecretType}&} cs)
		This method pushes a pair to the back of the stack secret. The parameter @var{index}
		is the permutation index and @var{cs} is the corresponding card secret.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret void clear ()
		This method clears the stack secret, i.e., it removes all pairs.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret size_t find_position (@code{size_t} index)
		This method searches for a given permutation index in the stack secret.
		It returns the corresponding position@footnote{According to the behaviour
		of the @code{[]}-operator, the zero denotes always the top-most position.} in
		the stack secret, if the @var{index} was found. Otherwise, the size of
		the stack secret is returned. Please note that in this case the returned
		value is not a valid position for an access to the stack secret.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret bool find (@code{size_t} index)
		This method searches for a given permutation index in the stack secret.
		It returns @code{true}, if such an @var{index} was found.
	@end deftypemethod
	
	@deftypemethod TMCG_StackSecret bool import (@code{std::string} s)
		This method imports the stack secret from a correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@defop {Destructor} TMCG_StackSecret ~TMCG_StackSecret ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_StackSecret std::ostream& << (@code{std::ostream&} out, @code{const TMCG_StackSecret<@var{CardSecretType}>&} stacksecret)
	This operator exports the given @var{stacksecret} to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_StackSecret std::istream& >> (@code{std::istream&} in, @code{TMCG_StackSecret<@var{CardSecretType}>&} stacksecret)
	This operator imports the given @var{stacksecret} from the input stream @var{in}.
	The data has to be delimited by a newline character. The @code{failbit} of
	the stream is set, if any parse error occurred.
@end deftypeop

@subsubsection Cryptographic Keys
@cindex Keys
LibTMCG provides the key data types only for the encoding scheme of
Schindelhauer@tie{}[Sc98], because it is very inefficient to perform the
corresponding key generation for every new game session. Furthermore,
the keys can be used to ensure the confidentiality and integrity of
short messages, even if the scheme of Barnett and Smart@tie{}[BS03]
has been applied for the card encoding. Therefore these structures may
be of independent interest. However, like in every public key cryptosystem
a trusted @acronym{PKI, Public Key Infrastructure} is needed. This might
not be a serious concern for a distributed game environment, if the players
compare their key fingerprints on a secure channel or if the service
provider exhibits certificates.

@deftp {Data type} TMCG_SecretKey
	This @code{struct} represents the secret part of the TMCG key. The
	underlying public key cryptosystem is due to Rabin with minor
	modifications for encryption padding (SAEP scheme
	of Boneh) and digital signatures (PRab scheme of Bellare and Rogaway).
	
	@deftypecv {Member} TMCG_SecretKey {std::string} name
		This string contains the name or a pseudonym of the key owner.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {std::string} email
		This string contains the email address of the key owner.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {std::string} type
		This string contains information about the key type. The common
		prefix is @code{TMCG/RABIN}. It is followed by the decimal encoded
		bit size of the modulus @math{m}. The suffix @code{NIZK} signals
		that the correctness of the key is shown by an appended non-interactive
		zero-knowledge proof. The single parts are separated by underscore
		characters @code{_}, e.g., @code{TMCG/RABIN_1024_NIZK} has the correct
		form.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {std::string} nizk
		This string contains two stages of the non-interactive zero-knowledge
		proof of Gennaro, Micciancio, and Rabin (@emph{An Efficient Non-Interactive
		Statistical Zero-Knowledge Proof System for Quasi-Safe Prime Products},
		ACM@tie{}CCS@tie{}1998). The proof shows that @math{m} was correctly
		generated as product of two primes both congruent to 3 (modulo 4).
		Further there is another non-interactive zero-knowledge proof appended
		which shows that the condition @math{y\in{\bf NQR}^\circ_m} holds.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {std::string} sig
		This string contains the self signature of the public key.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {mpz_t} m
		This is the public modulus @math{m = p \cdot q} which is the product
		of two secret primes @math{p} and @math{q}. The size of @math{m}
		is determined by the security parameter @code{TMCG_QRA_SIZE}.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {mpz_t} y
		This is the public quadratic non-residue @math{y\in {\bf NQR}^\circ_m}
		which is used in several zero-knowledge proofs of Schindelhauer's
		encoding scheme@tie{}[Sc98].
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {mpz_t} p
		This is the secret prime number @math{p} which is a factor of the
		modulus @math{m}.
	@end deftypecv
	
	@deftypecv {Member} TMCG_SecretKey {mpz_t} q
		This is the secret prime number @math{q} which is a factor of the
		modulus @math{m}.
	@end deftypecv
	
	@defop {Constructor} TMCG_SecretKey TMCG_SecretKey ()
		This default constructor initializes an empty secret key.
	@end defop
	
	@deftypeop {Constructor} TMCG_SecretKey {} TMCG_SecretKey (@code{const std::string&} n, @code{const std::string&} e, @code{unsigned long int} keysize @code{=TMCG_QRA_SIZE})
		This constructor generates a new secret key where @var{n} is the name or a
		pseudonym of the owner, @var{e} is a corresponding email address, and
		@var{keysize} is the desired bit length of the modulus @math{m}. The
		default value of the last argument is set to @code{TMCG_QRA_SIZE},
		if @var{keysize} is omitted in the call. Depending on @var{keysize}
		the generation is an highly time-consuming task and dots are sent to
		@code{std::cerr} as a progress indicator.
	@end deftypeop
	
	@deftypeop {Constructor} TMCG_SecretKey {} TMCG_SecretKey (@code{const std::string&} s)
		This constructor initializes the key from a correctly formated
		input string @var{s}.
	@end deftypeop
	
	@deftypeop {Constructor} TMCG_SecretKey {} TMCG_SecretKey (@code{const TMCG_SecretKey&} that)
		This is a simple copy-constructor and @var{that} is the key to be copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_SecretKey TMCG_SecretKey& = (@code{const TMCG_SecretKey&} that)
		This is a simple assignment-operator and @var{that} is the key to be assigned.
	@end deftypeop
	
	@deftypemethod TMCG_SecretKey bool check ()
		This method tests whether the self signature is valid and whether the
		non-interactive zero-knowledge proofs are sound. It returns @code{true},
		if all checks have been successfully passed. Due to the computational
		complexity of the verification procedure these checks are extremely
		time-consuming.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} fingerprint ()
		This method returns the fingerprint of the key. The fingerprint is the
		hexadecimal notation of the hash value (algorithm @code{TMCG_GCRY_MD_ALGO})
		on the members @code{name}, @code{email}, @code{type}, @code{m}, @code{y},
		@code{nizk}, and @code{sig}.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} selfid ()
		This method returns the real value of the self signature. The string
		@code{ERROR} is returned, if any parse error occurred. The string
		@code{SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG} is returned,
		if the self signature @code{sig} was empty.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} keyid (@code{size_t} size @code{=TMCG_KEYID_SIZE})
		This method returns the unique key identifier of length @var{size}.
		The default value of the first argument is set to @code{TMCG_KEYID_SIZE},
		if @var{size} is omitted in the call.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {size_t} keyid_size (@code{const std::string&} s)
		This method returns the length of the unique key identifier @var{s}.
		Zero is returned, if any parse error occurred.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} sigid (@code{std::string} s)
		This method returns the unique key identifier which is included in the
		signature @var{s}. The string @code{ERROR} is returned, if any parse
		error occurred.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey bool import (@code{std::string} s)
		This method imports the key from a correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey	bool decrypt (@code{char*} value, @code{std::string} s)
		This method decrypts the given encryption packet @var{s} and stores
		the content in @var{value} which is a pointer to a character array
		of size @code{TMCG_SAEP_S0}. The method returns @code{true}, if the
		decryption was successful.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} sign (@code{const std::string&} data)
		This method returns a digital signature on @var{data}.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey {std::string} encrypt (@code{const char*} value)
		This method encrypts the content of @var{value} which is a pointer to a
		character array of size @code{TMCG_SAEP_S0}. The method returns a
		corresponding encryption packet that can be decrypted by the owner of the
		secret key.
	@end deftypemethod
	
	@deftypemethod TMCG_SecretKey bool verify (@code{const std::string&} data, @code{std::string} s)
		This method verifies whether the signature @var{s} on @var{data} is valid
		or not. It returns @code{true}, if everything was sound.
	@end deftypemethod
	
	@defop {Destructor} TMCG_SecretKey ~TMCG_SecretKey ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_SecretKey std::ostream& << (@code{std::ostream&} out, @code{const TMCG_SecretKey&} key)
	This operator exports the given @var{key} to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_SecretKey std::istream& >> (@code{std::istream&} in, @code{TMCG_SecretKey&} key)
	This operator imports the given @var{key} from the input stream @var{in}.
	The data has to be delimited by a newline character. The @code{failbit}
	is set, if any parse error occurred.
@end deftypeop

@deftp {Data type} TMCG_PublicKey
	This @code{struct} represents the public part of the TMCG key.
	
	@deftypecv {Member} TMCG_PublicKey {std::string} name
		This string contains the name or a pseudonym of the key owner.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {std::string} email
		This string contains the email address of the key owner.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {std::string} type
		This string contains information about the key type. The common
		prefix is @code{TMCG/RABIN}. It is followed by the decimal encoded
		bit size of the modulus @math{m}. The suffix @code{NIZK} signals
		that the correctness of the key is shown by an appended non-interactive
		zero-knowledge proof. The single parts are separated by underscore
		characters @code{_}, e.g., @code{TMCG/RABIN_1024_NIZK} has the correct
		form.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {std::string} nizk
		This string contains two stages of non-interactive zero-knowledge
		proof of Gennaro, Micciancio and Rabin (ACM CCS, 1998). They show
		that the modulus @math{m} was correctly generated. Further there is another
		non-interactive zero-knowledge proof appended which shows that the condition
		@math{y\in{\bf NQR}^\circ_m} holds.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {std::string} sig
		This string contains the self signature of the public key.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {mpz_t} m
		This is the public modulus @math{m = p \cdot q} which is the product
		of two secret primes @math{p} and @math{q}. The size of @math{m}
		is determined by the security parameter @code{TMCG_QRA_SIZE}.
	@end deftypecv
	
	@deftypecv {Member} TMCG_PublicKey {mpz_t} y
		This is the public quadratic non-residue @math{y\in {\bf NQR}^\circ_m}
		which is used by several zero-knowledge proofs of the toolbox.
	@end deftypecv
	
	@defop {Constructor} TMCG_PublicKey TMCG_PublicKey ()
		This default constructor initializes an empty public key.
	@end defop
	
	@deftypeop {Constructor} TMCG_PublicKey {} TMCG_PublicKey (@code{const TMCG_SecretKey&} skey)
		This constructor initializes the key using public values
		of the secret key @var{skey}.
	@end deftypeop
	
	@deftypeop {Constructor} TMCG_PublicKey {} TMCG_PublicKey (@code{const TMCG_PublicKey&} pkey)
		This is a simple copy-constructor and @var{pkey} is the key to be copied.
	@end deftypeop
	
	@deftypeop {Operator} TMCG_PublicKey TMCG_PublicKey& = (@code{const TMCG_PublicKey&} that)
		This is a simple assignment-operator and @var{that} is the key to be assigned.
	@end deftypeop
	
	@deftypemethod TMCG_PublicKey bool check ()
		This method tests whether the self signature is valid and whether the
		non-interactive zero-knowledge proofs are sound. It returns @code{true},
		if all checks have been successfully passed. Due to the computational
		complexity of the verification procedure these checks are extremely
		time-consuming.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} fingerprint ()
		This method returns the fingerprint of the key. The fingerprint is the
		hexadecimal notation of the hash value (algorithm @code{TMCG_GCRY_MD_ALGO})
		on the members @code{name}, @code{email}, @code{type}, @code{m}, @code{y},
		@code{nizk}, and @code{sig}.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} selfid ()
		This method returns the real value of the self signature. The string
		@code{ERROR} is returned, if any parse error occurred. The string
		@code{SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG} is returned,
		if the self signature @code{sig} was empty.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} keyid (@code{size_t} size @code{=TMCG_KEYID_SIZE})
		This method returns the unique key identifier of length @var{size}.
		The default value of the first argument is set to @code{TMCG_KEYID_SIZE},
		if @var{size} is omitted in the call.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {size_t} keyid_size (@code{const std::string&} s)
		This method returns the length of the unique key identifier @var{s}.
		Zero is returned, if any parse error occurred.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} sigid (@code{std::string} s)
		This method returns the unique key identifier which is included in the
		signature @var{s}. The string @code{ERROR} is returned, if any parse
		error occurred.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey bool import (@code{std::string} s)
		This method imports the key from a correctly formated input string
		@var{s}. It returns @code{true}, if the import was successful.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey {std::string} encrypt (@code{const char*} value)
		This method encrypts the content of @var{value} which is a pointer to a
		character array of size @code{TMCG_SAEP_S0}. The method returns a
		corresponding encryption packet that can be decrypted by the owner of the
		secret key.
	@end deftypemethod
	
	@deftypemethod TMCG_PublicKey bool verify (@code{const std::string&} data, @code{std::string} s)
		This method verifies whether the signature @var{s} on @var{data} is valid
		or not. It returns @code{true}, if everything was sound.
	@end deftypemethod
	
	@defop {Destructor} TMCG_PublicKey ~TMCG_PublicKey ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftypeop {Operator} TMCG_PublicKey std::ostream& << (@code{std::ostream&} out, @code{const TMCG_PublicKey&} key)
	This operator exports the given @var{key} to the output stream @var{out}.
@end deftypeop

@deftypeop {Operator} TMCG_PublicKey std::istream& >> (@code{std::istream&} in, @code{TMCG_PublicKey&} key)
	This operator imports the given @var{key} from the input stream @var{in}.
	The data has to be delimited by a newline character. The @code{failbit}
	is set, if any parse error occurred.
@end deftypeop

@deftp {Data type} TMCG_PublicKeyRing
	This @code{struct} is just a simple container for TMCG public keys. There are
	no particular methods provided by @code{TMCG_PublicKeyRing}. You have to use
	the regular interface of the STL container @code{std::vector} to access the
	single keys of the ring.
	
	@deftypecv {Member} TMCG_PublicKeyRing {std::vector<TMCG_PublicKey>} keys
		This is the real container that is used to store the keys.
	@end deftypecv
	
	@defop {Constructor} TMCG_PublicKeyRing TMCG_PublicKeyRing ()
		This default constructor initializes an empty public key ring.
	@end defop
	
	@defop {Constructor} TMCG_PublicKeyRing TMCG_PublicKeyRing (@code{size_t} n)
		This constructor initializes the container for storing exactly
		@var{n} keys.
	@end defop
	
	@defop {Destructor} TMCG_PublicKeyRing ~TMCG_PublicKeyRing ()
		This destructor releases all occupied resources.
	@end defop
@end deftp


@subsection Classes
@cindex Classes
LibTMCG consists of several C++ classes. Some of them are only extensions
or optimizations, but other provide necessary interfaces to perform the basic
operations in secure card games, e.g., the creation of open cards, the masking
of cards, the opening of masked cards, the verifiable secret shuffle of a stack,
and more general tasks like distributed key generation procedures. Each class
implements the main functionality of the corresponding research
paper@tie{}[Sc98,BS03,Gr05]. The author names are a prefix of the class
name and the then following part is an abbreviation of the title.

@subsubsection Verifiable @var{k}-out-of-@var{k} Threshold Masking Function
The two classes of this subsection are concrete instantiations of Barnett
and Smart's VTMF primitive@tie{}[BS03]. More formally, the authors specify
four different protocols:
@itemize @bullet
	@item Key Generation Protocol
	@item Verifiable Masking Protocol
	@item Verifiable Re-masking Protocol
	@item Verifiable Decryption Protocol
@end itemize
Each protocol uses low-level operations on an appropriately chosen algebraic
group @math{G}. The choice of this group is crucial to the security of the
card encoding scheme and thus to the high-level operations on cards resp.
stacks.

There are just a few methods and members of these classes that might be of
interest for an application programmer, e.g. the methods of the key generation
protocol. The other stuff is only used internally by high-level operations
of @code{SchindelhauerTMCG}. Therefore this manual omits the description of
such internal functions and members.

@deftp {Class} BarnettSmartVTMF_dlog
	This class implements the discrete logarithm instantiation of the VTMF
	primitive in the field @math{{\bf Z}/p{\bf Z}}, where @math{p} is a large
	prime number. The mathematical computations are performed in the finite cyclic
	subgroup @math{G} of prime order @math{q} such that @math{p = kq + 1} holds
	for some @math{k\in {\bf Z}}. The security relies on the DDH assumption in
	@math{G}, i.e., the distribution @math{\{g^a, g^b, g^{ab}\}} is computationally
	indistinguishable from @math{\{g^a, g^b, g^c\}}, where @math{g} is a
	generator of @math{G} and @math{a, b, c} are chosen at random from
	@math{{\bf Z}_q}. Currently, this well-established assumption is believed to
	hold, if @math{p} and @math{q} are chosen according to the predefined security
	parameters of LibTMCG.
	
	@deftypecv {Member} BarnettSmartVTMF_dlog {mpz_t} p
		This is the public prime number @math{p} which defines the
		underlying field @math{{\bf Z}/p{\bf Z}}.
	@end deftypecv
	
	@deftypecv {Member} BarnettSmartVTMF_dlog {mpz_t} q
		This is the public prime number @math{q} which defines the
		unerlying cyclic group @math{G}. @math{G} is a subgroup of
		@math{{\bf Z}/p{\bf Z}} and is exactly of order @math{q}.
	@end deftypecv
	
	@deftypecv {Member} BarnettSmartVTMF_dlog {mpz_t} g
		This is the fixed public generator @math{g} of the underlying
		group @math{G}.
	@end deftypecv
	
	@deftypecv {Member} BarnettSmartVTMF_dlog {mpz_t} k
		This is a public integer @math{k} such that @math{p = kq + 1} holds.
	@end deftypecv
	
	@deftypecv {Member} BarnettSmartVTMF_dlog {mpz_t} h
		This is the common public key @math{h}.
	@end deftypecv
	
	@deftypeop {Constructor} BarnettSmartVTMF_dlog {} BarnettSmartVTMF_dlog (@code{unsigned long int} fieldsize @code{=TMCG_DDH_SIZE}, @code{unsigned long int} subgroupsize @code{=TMCG_DLSE_SIZE})
		This constructor creates a new VTMF instance. That means, the primes
		@math{p} and @math{q} are randomly and uniformly chosen such that
		they have length @var{fieldsize} bit and @var{subgroupsize} bit, respectively.
		Further, a generator @math{g} for the unique subgroup of order @math{q} is
		chosen at random. If the arguments are omitted, then @var{fieldsize} and
		@var{subgroupsize} are set to their default values @code{TMCG_DDH_SIZE} and
		@code{TMCG_DLSE_SIZE}, respectively.
		Depending on @var{fieldsize} and @var{subgroupsize} the group generation
		is a very time-consuming task and some dots are sent to @code{std::cerr} as
		a progress indicator.
	@end deftypeop
	
	@deftypeop {Constructor} BarnettSmartVTMF_dlog {} BarnettSmartVTMF_dlog (@code{std::istream&} in, @code{unsigned long int} fieldsize @code{=TMCG_DDH_SIZE}, @code{unsigned long int} subgroupsize @code{=TMCG_DLSE_SIZE})
		This constructor initializes the VTMF instance from a correctly formated
		input stream @var{in}. For example, such a stream can be generated by calling
		the method @code{PublishGroup} of an already created instance. The arguments
		@var{fieldsize} and @var{subgroupsize} are stored for later following usage,
		e.g. by the method @code{CheckGroup} as explained below.
		If these arguments are omitted, then they are set to the default values
		@code{TMCG_DDH_SIZE} and @code{TMCG_DLSE_SIZE}, respectively.
	@end deftypeop
	
	@deftypemethod BarnettSmartVTMF_dlog bool CheckGroup ()
		This method checks whether @math{p} and @math{q} have appropriate sizes
		with respect to the bit lengths given during the initialization of the
		corresponding instance. Further, it checks whether @math{p} has the correct
		form (i.e. @math{p = kq +1}), whether @math{p} and @math{q} are probable
		prime, and whether @math{g} is a generator of the subgroup @math{G}. It
		returns @code{true}, if all of these checks have been passed successfully.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog void PublishGroup (@code{std::ostream&} out)
		This method exports all necessary group parameters of @math{G} to
		the given output stream @var{out}, so other VTMF instances of @math{G}
		can be initalized, e.g. with the second constructor of
		@code{BarnettSmartVTMF_dlog}.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog void KeyGenerationProtocol_GenerateKey ()
		This method generates a VTMF key pair and stores the pair internally for
		a later following usage. It must be called before any other part
		of the key generation protocol is executed. Otherwise, the produced results
		are wrong.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog void KeyGenerationProtocol_PublishKey (@code{std::ostream&} out)
		This method exports the public part of the generated VTMF key pair to the
		given output stream @var{out}. Further, it appends a non-interactive
		zero-knowledge proof of knowledge which shows that the instance knows the
		secret part.
		Due to the non-interactive nature of this proof the method has to be called
		only once while the computed output can be reused multiple times if necessary.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog bool KeyGenerationProtocol_UpdateKey (@code{std::istream&} in)
		This method reads the public part of a VTMF key and the proof of knowledege
		from the input stream @var{in}. It appends the key to the common public key
		and returns @code{true}, if the given proof was sound. Otherwise, @code{false}
		is returned.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog bool KeyGenerationProtocol_RemoveKey (@code{std::istream&} in)
		This method reads the public part of a VTMF key and the corresponding proof
		of knowledege from the input stream @var{in}. It removes the key from the
		common public key and returns @code{true}, if the key was previously appended
		by @code{KeyGenerationProtocol_UpdateKey} as explained above.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog void KeyGenerationProtocol_Finalize ()
		This method must be called after any update
		(@code{KeyGenerationProtocol_UpdateKey}) or removal
		(@code{KeyGenerationProtocol_RemoveKey}) has been performed
		on the common public key.
	@end deftypemethod
	
	@defop {Destructor} BarnettSmartVTMF_dlog ~BarnettSmartVTMF_dlog ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@deftp {Subclass of @code{BarnettSmartVTMF_dlog}} BarnettSmartVTMF_dlog_GroupQR
	This subclass implements the discrete logarithm instantiation of the VTMF
	primitive in the field @math{{\bf Z}/p{\bf Z}}, where @math{p} is a large
	prime number. The mathematical computations are performed in the finite
	cyclic subgroup @math{G} (quadratic residues modulo @math{p}) of prime order
	@math{q}, where @math{p = 2q + 1} holds. The security relies on the DDH
	assumption in @math{G}, i.e., the distribution @math{\{g^a, g^b, g^{ab}\}}
	is computationally indistinguishable from @math{\{g^a, g^b, g^c\}}, where
	@math{g} is a generator of @math{G} and @math{a, b, c} are chosen at random
	from @math{{\bf Z}_q}. Currently, this well-established assumption is believed
	to hold, if @math{p} and @math{q} are chosen according to the predefined
	security parameters of LibTMCG.
	
	@deftypecv {Member} BarnettSmartVTMF_dlog_GroupQR {mpz_t} p
		This is the public prime number @math{p} which defines the
		underlying field @math{{\bf Z}/p{\bf Z}}.
	@end deftypecv
	
	@deftypecv {Member} BarnettSmartVTMF_dlog_GroupQR {mpz_t} q
		This is the public prime number @math{q} which defines the
		underlying cyclic group @math{G}. @math{G} denotes the unique
		subgroup of quadratic residues modulo @math{p} which is
		exactly of order @math{q}, if @math{p = 2q + 1} holds.
	@end deftypecv
	
	@deftypecv {Member} BarnettSmartVTMF_dlog_GroupQR {mpz_t} g
		This is the fixed public generator @math{g} of the underlying
		group @math{G}.
	@end deftypecv
	
	@deftypecv {Member} BarnettSmartVTMF_dlog_GroupQR {mpz_t} k
		This integer is fixed by @math{k = 2}.
	@end deftypecv
	
	@deftypecv {Member} BarnettSmartVTMF_dlog_GroupQR {mpz_t} h
		This is the common public key @math{h}.
	@end deftypecv
	
	@deftypeop {Constructor} BarnettSmartVTMF_dlog_GroupQR {} @*BarnettSmartVTMF_dlog_GroupQR (@code{unsigned long int} fieldsize @code{=TMCG_DDH_SIZE}, @code{unsigned long int} exponentsize @code{=TMCG_DLSE_SIZE})
		This constructor creates a new VTMF instance. That means, the safe prime
		@math{p} is randomly and uniformly chosen such that it has a length of
		@var{fieldsize} bit.
		Further, the generator @math{g} is initially set up by @math{2} and then
		shifted by @math{@var{fieldsize} - @var{exponentsize}} bit positions,
		according to the procedure described by Koshiba and Kurosawa (see
		@emph{Short Exponent Diffie-Hellman Problems}, PKC@tie{}2004, LNCS@tie{}2947).
		If the arguments of the constructor are omitted, then @var{fieldsize} and
		@var{exponentsize} are set to their default values @code{TMCG_DDH_SIZE} and
		@code{TMCG_DLSE_SIZE}, respectively.
		Depending on @var{fieldsize} and @var{exponentsize} the group generation
		is a very time-consuming task and some dots are sent to @code{std::cerr} as
		a progress indicator.
	@end deftypeop
	
	@deftypeop {Constructor} BarnettSmartVTMF_dlog_GroupQR {} @*BarnettSmartVTMF_dlog_GroupQR (@code{std::istream&} in, @code{unsigned long int} fieldsize @code{=TMCG_DDH_SIZE}, @code{unsigned long int} exponentsize @code{=TMCG_DLSE_SIZE})
		This constructor initializes the VTMF instance from a correctly formated
		input stream @var{in}. For example, such a stream can be generated by calling
		the method @code{PublishGroup} of an already created instance. The arguments
		@var{fieldsize} and @var{exponentsize} are stored for later following usage,
		e.g. by the method @code{CheckGroup} as explained below.
		If these arguments are omitted, then they are set to the default values
		@code{TMCG_DDH_SIZE} and @code{TMCG_DLSE_SIZE}, respectively.
	@end deftypeop
	
	@deftypemethod BarnettSmartVTMF_dlog_GroupQR bool CheckGroup ()
		This method checks whether @math{p} and @math{q} have appropriate sizes
		with respect to the bit lengths given during the initialization of the
		corresponding instance. Further, it checks whether @math{p} has the correct
		form (i.e. @math{p = 2q +1}), whether @math{p} and @math{q} are probable
		prime, and whether @math{g} is a generator of the subgroup @math{G}. It
		returns @code{true}, if all of these checks have been passed successfully.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog_GroupQR void PublishGroup (@code{std::ostream&} out)
		This method exports all necessary group parameters of @math{G} to
		the given output stream @var{out}, so other VTMF instances of @math{G}
		can be initalized, e.g. with the second constructor of
		@code{BarnettSmartVTMF_dlog_GroupQR}.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog_GroupQR void KeyGenerationProtocol_GenerateKey ()
		This method generates a VTMF key pair and stores the pair internally for
		a later following usage. It must be called before any other part
		of the key generation protocol is executed. Otherwise, the produced results
		are wrong.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog_GroupQR void KeyGenerationProtocol_PublishKey (@code{std::ostream&} out)
		This method exports the public part of the generated VTMF key pair to the
		given output stream @var{out}. Further, it appends a non-interactive
		zero-knowledge proof of knowledge which shows that the instance knows the
		secret part.
		Due to the non-interactive nature of this proof the method has to be called
		only once while the computed output can be reused multiple times if necessary.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog_GroupQR bool KeyGenerationProtocol_UpdateKey (@code{std::istream&} in)
		This method reads the public part of a VTMF key and the proof of knowledege
		from the input stream @var{in}. It appends the key to the common public key
		and returns @code{true}, if the given proof was sound. Otherwise, @code{false}
		is returned.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog_GroupQR bool KeyGenerationProtocol_RemoveKey (@code{std::istream&} in)
		This method reads the public part of a VTMF key and the corresponding proof
		of knowledege from the input stream @var{in}. It removes the key from the
		common public key and returns @code{true}, if the key was previously appended
		by @code{KeyGenerationProtocol_UpdateKey} as explained above.
	@end deftypemethod
	
	@deftypemethod BarnettSmartVTMF_dlog_GroupQR void KeyGenerationProtocol_Finalize ()
		This method must be called after any update
		(@code{KeyGenerationProtocol_UpdateKey}) or removal
		(@code{KeyGenerationProtocol_RemoveKey}) has been performed
		on the common public key.
	@end deftypemethod
	
	@defop {Destructor} BarnettSmartVTMF_dlog_GroupQR @*~BarnettSmartVTMF_dlog_GroupQR ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@subsubsection Verifiable Secret Shuffle of Homomorphic Encryptions
Recently, Groth@tie{}[Gr05] has proposed a very efficient solution to perform
a verifiable shuffle of homomorphically encrypted values. He describes an
honest verifier zero-knowledge argument which shows the correctness of a
shuffle. Beside other applications (e.g. verifiable mix networks, electronic
voting) his protocol can be used to show with overwhelming probablity that
the secret shuffle of a deck of cards was performed correctly. The
computational complexity and the produced communication traffic are superior
to previously deployed techniques (e.g. Schindelhauer's cut-and-choose method).
LibTMCG provides the first known implementation of Groth's famous protocol.
However, it can only be used along with the VTMF card encoding scheme of
Barnett and Smart.

Our implementation uses the unconditionally hiding homomorphic commitment
scheme due to Pedersen. This choice seems to be reasonable for the intention
of our library.

Further, to the best of our knowledge it is still unknown whether or not
Groth's protocol retains the zero-knowledge property, if it is executed in
a concurrent setting. Hence one should be careful and avoid parallel protocol
executions of the same instance.

@deftp {Class} GrothVSSHE
	This class provides the low-level interface for Groth's protocol.
	There are just a few methods that might be of general interest.
	All other components are only used internally by high-level operations
	and thus their description is omitted here.
	
	@deftypeop {Constructor} GrothVSSHE {} GrothVSSH (@code{size_t} n, @code{mpz_srcptr} p_ENC, @code{mpz_srcptr} q_ENC, @code{mpz_srcptr} k_ENC, @code{mpz_srcptr} g_ENC, @code{mpz_srcptr} h_ENC, @code{unsigned long int} ell_e @code{=TMCG_GROTH_L_E})
		This constructor creates a new instance. Its low-level operations
		are later used to show the correctness of a shuffle of at most
		@var{n} cards. The protocol and some parameters of the commitment
		scheme are initialized by the members of the corresponding VTMF
		instance. Consequently, @var{p_ENC} is the prime number @math{p}
		which determines the field @math{{\bf Z}/p{\bf Z}}, @var{q_ENC}
		is the order of the underlying subgroup @math{G}, i.e. the prime
		number @math{q}, and @var{k_ENC} is the integer such that
		@math{p = qk + 1} holds. Further, @var{g_ENC} is the generator of
		@math{G}, i.e. the fixed number @math{g}, and finally @var{h_ENC}
		is the common public key @math{h}. The positive integer @var{ell_e}
		is the security parameter which controls the soundness error of
		the protocol. The default value is defined by @code{TMCG_GROTH_L_E}.
		
		Note that the generators of the commitment scheme are randomly
		and uniformly chosen from @math{{\bf Z}_q}. Therefore this
		constructor should be only used by the session leader.
		Further it is important that the VTMF key generation protocol
		has been finished before the value of @math{h} is passed to the
		constructor.
	@end deftypeop
	
	@deftypeop {Constructor} GrothVSSHE {} GrothVSSH (@code{size_t} n, @code{std::istream&} in, @code{unsigned long int} ell_e @code{=TMCG_GROTH_L_E})
		This constructor initializes the instance from a correctly formated
		input stream @var{in}. For example, such a stream can be generated by
		calling the method @code{PublishGroup} of an already created instance.
		Later the instance can be used to show the correctness of a shuffle of
		at most @var{n} cards.
		The positive integer @var{ell_e} controls the soundness error of
		the protocol. The default value is defined by @code{TMCG_GROTH_L_E},
		if this argument is omitted.
	@end deftypeop
	
	@deftypemethod GrothVSSHE bool CheckGroup ()
		This method checks whether the initialized commitment scheme is sound.
		It returns @code{true}, if all tests have been passed successfully.
	@end deftypemethod
	
	@deftypemethod GrothVSSHE void PublishGroup (@code{std::ostream&} out)
		This method exports all necessary parameters of the instance to
		the given output stream @var{out}, so other instances can be
		initalized, e.g. with the second constructor of @code{GrothVSSHE}.
	@end deftypemethod

	@defop {Destructor} GrothVSSHE ~GrothVSSHE ()
		This destructor releases all occupied resources.
	@end defop
@end deftp

@subsubsection Toolbox for Mental Card Games

@chapter Examples
@cindex Examples
First, please have a look at the well-documented examples and test programs in
the directory @file{tests/}, e.g. @file{SchwarzerPeterAlice.cc} and
@file{SchwarzerPeterBob.cc}, respectively.
A detailed exposition including source code fragments will be given in this
chapter.

@section Key Generation and Game Setup
@section Operations on Cards
@subsection Creating an Open Card
@subsection Masking and Remasking of a Card
@subsection Opening a Masked Card

@section Operations on Stacks
@subsection Creating an Open Stack
@subsection Shuffle a Stack
@subsection Drawing a Card


@c **********************************************************
@c *******************  Appendices  *************************
@c **********************************************************
@include gpl.texi
@include fdl.texi

@unnumbered General Index
@printindex cp

@unnumbered API Index
@printindex fn

@bye
