\input texinfo
@c %**start of header
@documentencoding ISO-8859-1
@setfilename libTMCG.info
@include version.texi
@settitle The LibTMCG Reference Manual
@c %**end of header

@c Include data type index into function index
@syncodeindex tp fn

@c A simple macro for optional variables. (copied from gcrypt manual)
@macro ovar{varname}
@r{[}@var{\varname\}@r{]}
@end macro

@copying
This is the reference manual of LibTMCG.

Revision $Id: libTMCG.texi,v 1.14 2006/03/08 08:37:30 stamer Exp $.

Copyright @copyright{} 2005, 2006 Heiko Stamer <@email{stamer@@gaos.org}>.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts. A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end quotation
@end copying

@titlepage
@title The LibTMCG Reference Manual
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Heiko Stamer <@email{stamer@@gaos.org}>

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top LibTMCG Reference Manual

@insertcopying
@end ifnottex

@c **********************************************************
@c *******************  Introduction  ***********************
@c **********************************************************
@chapter Introduction
`@acronym{LibTMCG}' is a general purpose C++ library for
creating secure electronic card games. The most remarkable
feature is the absence of a trusted third party (TTP), i.e.
neither a central game server nor similar facilities are
necessary. To emphasize this point again: With the present
library there is no need for an independent referee, because
the applied protocols provide a basic level of confidentiality
and fairness by itself. Of course, we cannot avoid that
malicious players share information about their private
cards, but the protocols ensure that the shuffle of the
deck is performed randomly (presumed that at least one
player is honest) and thus the cards will be distributed
uniformly among the players. Further, no coalition can
learn the private cards of a player agains his will (except
for trivial conclusions). The corresponding cryptographic
problem, actually called ''Mental Poker'', has been studied
since 1979 (Shamir, Rivest, and Adleman) by many authors.

Our implementation relies on advanced cryptographic
techniques---the so-called zero-knowledge proofs. Using
these `building blocks' the high-level protocols minimize
the effect of coalitions and preserve the confidentiality
of the players' strategy, i.e. the players are not required
to reveal their cards at the end of the game to show that
they did not cheat.

LibTMCG is @emph{Free Software} according to the definition
of the @uref{http://www.fsf.org/licensing/essays/free-sw.html,,
Free Software Foundation}.

@c **********************************************************
@section Further Reading
The cryptographic background and a detailed discussion of
the implementation issues is beyond the scope of this manual.
The interested reader is refered to the following papers:
@quotation [Sch98]
	Christian Schindelhauer.
	@emph{Toolbox for Mental Card Games.}@*
	Technical Report A-98-14, University of L@"ubeck, 1998.
@end quotation
@quotation [BS03]
	Adam Barnett and Nigel P. Smart.
	@emph{Mental Poker Revisited.}@*
	In K.G. Paterson (Ed.): Cryptography and Coding 2003,
	Lecture Notes in Computer Science 2898, pp. 370--383, 2003.
@end quotation
@quotation [Gr05]
	Jens Groth.
	@emph{A Verifiable Secret Shuffle of Homomorphic Encryptions.}@*
	Cryptology ePrint Archive, Report 2005/246, 2005.
@end quotation
@quotation [St04]
	Heiko Stamer.
	@emph{Kryptographische Skatrunde.} (in German)@*
	Offene Systeme (ISSN 1619-0114), 4:10--30, 2004.@*
	@uref{http://www.gaos.org/~stamer/OS-4-2004-openskat_rev2005.pdf}
@end quotation
@quotation [St05]
	Heiko Stamer.
	@emph{Efficient Electronic Gambling: An Extended Implementation
	of the Toolbox for Mental Card Games.}@*
	Proceedings of the Western European Workshop on Research in
	Cryptology (WEWoRC 2005), Lecture Notes in Informatics P-74,
	pp. 1--12, 2005.
@end quotation

@c **********************************************************
@section Getting Started
This manual describes the application programming interface
(API) of LibTMCG. All public classes and security parameters
are explained. The reader should have an advanced knowledge
in applied cryptography and C++ programming. Reference is
made at this point to the famous @cite{Handbook of Applied
Cryptography} for a brief introduction.

This document follows, in style and rarely in phrasing,
the @cite{Reference Manual of the GNU Crypto Library}.
Thus don't be surprised, if you recognize some obvious
analogies.

@c **********************************************************
@section Preparation
LibTMCG depends on the two other basic libraries. Therefore
you will need mandatory their corresponding development
files to build your application properly:
@itemize @bullet
	@item GNU Multiple Precision Arithmetic Library (@file{libgmp}),
		Version @math{\ge} 4.1.0
		
		This library provides a powerful framework for performing
		arbitrary precision arithmetic on integers. Further reasons
		for chosing this dependency are the license compatibility,
		portability, vital maintainance, and, of course, the
		reasonable performance.
		
	@item GNU Crypto Library (@file{libgcrypt}),
		Version @math{\ge} 1.2.0
		
		This library provides some basic cryptographic algorithms
		(e.g. RIPEMD-160) and an easily usable interface to obtain
		cryptographically strong pseudo random numbers.
		
@end itemize
We suppose that the reader is familiar with these libraries
because their correct installation and configuration is
crucial to the security of the entire application.

@c **********************************************************
@section Headers and Namespaces
The interface definitions of the classes and the constant security
parameters@footnote{These parameters are fixed at compile time.
Please don't change anything unless you know exactly what you are
doing, and what the dangers are! Beside the apparent security
concerns you will probably break the compatibility with other
applications.} are provided by the central header file
@file{libTMCG.hh}. You have to include this file in all of your
sources, either directly or through some other method.

@example
#include <libTMCG.hh>
@end example

There are no uniform C++ namespaces for the most parts of the
library. Some classes have the common prefix @code{TMCG_*} or
@code{VTMF_*} while others are composed of the author names
of the related research paper. Further there are internally
used C functions which might produce conflicting names. These
function names are prepended by @code{mpz_*} because they are
extensions for the integer support of the GNU Multiple Precision
Arithmetic Library.

@c **********************************************************
@section Building Sources
If you want to compile a source file including the @file{libTMCG.hh}
header file, you must make sure that the compiler can find it in the
directory hierarchy. This is accomplished by adding the path of the
corresponding directory to the compilers include file search path
(via the @option{-I} option).

However, the path to the include file is determined at the time the
source is configured. To solve this problem, LibTMCG ships with a small
helper program @command{libTMCG-config} that knows the path to the
include file and other configuration options. The options that need
to be added to the compiler invocation at compile time are output by
the @option{--cflags} option to @command{libTMCG-config}. The following
example shows how it can be used at the command line:

@example
g++ -c foo.cc `libTMCG-config --cflags`
@end example

Adding the output of @samp{libTMCG-config --cflags} to the compilers
command line will ensure that the compiler can find the library header
file.

A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files. For this to work,
the path to the library files has to be added to the library search
path (via the @option{-L} option). For this, the option @option{--libs}
to @command{libTMCG-config} can be used. For convenience, this option
also outputs all other options that are required to link the program
with the library (in particular, the @samp{-lTMCG} option). The example
shows how to link @file{foo.o} with LibTMCG to a program @command{foo}.

@example
g++ -o foo foo.o `libTMCG-config --libs`
@end example

Of course you can also combine both examples to a single command by
specifying both options to @command{libTMCG-config}:

@example
g++ -o foo foo.c `libTMCG-config --cflags --libs`
@end example

@c **********************************************************
@section Building Sources Using GNU Automake
You can use GNU Automake to obtain automatically generated
Makefiles. If you do that you do not have to worry about finding and
invoking the @command{libTMCG-config} script at all.
LibTMCG provides an extension that does all the work for you.

@defmac AM_PATH_LIBTMCG (@ovar{minimum-version}, @ovar{action-if-found}, @ovar{action-if-not-found})
Check whether LibTMCG (at least version @var{minimum-version}, if given)
exists on the host system. If it is found, execute @var{action-if-found},
otherwise do @var{action-if-not-found}.

Additionally, the function defines @code{LIBTMCG_CFLAGS} to the
flags needed for compilation of the program to find the @file{libTMCG.hh}
header file, and @code{LIBTMCG_LIBS} to the linker flags needed to link
the program with LibTMCG.
@end defmac

You can use the defined variables in @file{Makefile.am} like below:

@example
AM_CPPFLAGS = $(LIBTMCG_CFLAGS)
LDADD = $(LIBTMCG_LIBS)
@end example

@c **********************************************************
@section Initializing the Library
The first step you have to do is the initalization of
LibTMCG. The following function must be invoked early in
your program, i.e. before you make use of any capability of
the library.

@deftypefun bool init_libTMCG ()
The function checks whether the installed third-party libraries
match their required versions. Further it initalize them
and returns @code{true}, if everything was sound. Otherwise
@code{false} is returned and an appropriate error message
is sent to @code{stderr}.
@end deftypefun

@c **********************************************************
@c *************************  API  **************************
@c **********************************************************
@chapter Application Programming Interface

@c **********************************************************
@section Preprocessor Defined Global Symbols
Please note that the following macros are fixed at compile
time of LibTMCG and cannot be changed in your application.
They are only provided here for informational purposes.

@defmac TMCG_GROTH_L_E
Defines the security parameter @math{\ell_e} of Groth's interactive
shuffle argument@tie{}[Gr05]. The default value is @code{80L} which
implies a soundness error probability @math{{} \le 2^{-80}}. For
the purposes of this library the bound chosen is reasonable small
enough.
@end defmac

@defmac TMCG_DDH_SIZE
Defines the security parameter (field size in bit) of the DDH-hard
group @math{G} which is used by the card encoding scheme of Barnett
and Smart@tie{}[BS03]. The underlying assumptions are DDH, CDH, and DLOG.
The default value is @code{1024L}.
@end defmac

@defmac TMCG_DLSE_SIZE
Defines the security parameter (subgroup size in bit) of the group
@math{G} which is used by the card encoding scheme of Barnett and
Smart@tie{}[BS03]. The underlying assumptions are DLSE (related to DDH),
and DLOG. The default value is @code{160L}.
@end defmac

@defmac TMCG_GCRY_MD_ALGO
Defines the message digest algorithm for digital signatures and
the Fiat-Shamir heuristic. The security proofs of the most non-interactive
zero-knowledge proofs (NIZK) are established in the so-called random
oracle model, i.e. one supposes that the used hash function behaves
like an ideal random function (which cannot exist in a real world scenario).
However, this assumption seems to be reasonable, if carefully implemented.
The default value is @code{GCRY_MD_RMD160}. This constant represents
the hash algorithm RIPEMD-160 which has an output length of 160 bit.
Thus it leads to a security level of approximately @math{2^{80}}, assuming
that a birthday-attack is the best known attack agains this algorithm.
@end defmac

@defmac TMCG_KEYID_SIZE
Defines the length (in characters w.r.t. @code{TMCG_MPZ_IO_BASE})
of the distinctive suffix for the unique key identifier. The default
value is @code{5} which spans a reasonable name space for at least
4096 different keys.

Each key identifier starts with the string @code{ID} followed by
the decimal coded value @code{TMCG_KEYID_SIZE} and an appended
carret symbol @code{^}. The final suffix consists of number
@code{TMCG_KEYID_SIZE} characters of the self signature.
@end defmac

@defmac TMCG_KEY_NIZK_STAGE1
Defines the security parameter (number of iterations) of the NIZK
proof (stage 1) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{16} which implies
a soundness error probability @math{{} \le d^{-16}}, where
@math{d = gcd(m, \phi(m))}. This parameter is only relevant for the
card encoding scheme of Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_KEY_NIZK_STAGE2
Defines the security parameter (number of iterations) of the NIZK
proof (stage 2) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{128} which implies
a soundness error probability @math{{} \le 2^{-128}}.
This parameter is only relevant for the card encoding scheme of
Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_KEY_NIZK_STAGE3
Defines the security parameter (number of iterations) of the NIZK
proof (stage 3) to convince all verifiers that the TMCG key was
correctly generated. The default value is @code{128} which implies
a soundness error probability @math{{} \le 2^{-128}}.
This parameter is only relevant for the card encoding scheme of
Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_LIBGCRYPT_VERSION
Defines the needed version of the GNU Crypto Library.
The default value is @code{"1.2.0"}.
@end defmac

@defmac TMCG_LIBGMP_VERSION
Defines the needed version of the GNU Multiple Precision Arithmetic Library.
The default value is @code{"4.1.0"}.
@end defmac

@defmac TMCG_MAX_CARDS
Defines the maximum number of stackable cards.
The default value is @code{128L}.
@end defmac

@defmac TMCG_MAX_PLAYERS
Defines the maximum number of participating players in the scheme of
Schindelhauer@tie{}[Sc98]. The default value is @code{32L}.
@end defmac

@defmac TMCG_MAX_TYPEBITS
Defines the number of bits to represent the card type in the scheme of
Schindelhauer@tie{}[Sc98]. The default value @code{8L} implies that 256
different cards are possible.
@end defmac

@defmac TMCG_MPZ_IO_BASE
Defines the input/ouput encoding base of the @code{iostream} operators
for arbitrary precision integers. The default value @code{36L} is currently
the largest base supported by the GNU Multiple Precision Arithmetic Library.
@end defmac

@defmac TMCG_PRAB_K0
Defines the security parameter @math{k_0} (in characters) for the PRab
digital signature scheme of Bellare and Rogaway. The default value is
@code{20} which leads to a security level of approximately @math{2^{80}}.
@end defmac

@defmac TMCG_QRA_SIZE
Defines the security parameter (size of the modulus @math{m = p \cdot q}
in bit) of the TMCG key. The underlying assumptions are QRA and FAKTOR.
The default value is @code{1024L}. This parameter is mostly relevant
for the card encoding scheme of Schindelhauer@tie{}[Sc98].
@end defmac

@defmac TMCG_SAEP_S0
Defines the security parameter @math{s_0} (in characters) for the Rabin-SAEP
encryption scheme of Boneh. The default value @code{20} implies a security
around @math{2^{80}} against CCA.
@end defmac

@defmac TMCG_HASH_COMMITMENT
Defines whether or not shortened commitments are used by the shuffle
proof of Schindelhauer@tie{}[Sc98]. The default value is @code{true},
because it decreases the communication complexity enormously. However,
as a consequence the soundness property of the proof only remains valid
in the random oracle model.
@end defmac

@defmac TMCG_MAX_FPOWM_T
Defines the maximum size of a possible exponent (in bit) used with the
fast exponentiation procedures based on precomputated tables.
The default value is @code{2048}.
@end defmac

@c **********************************************************
@section Public Data Types and Classes

@subsection Data Types

@subsubsection Cryptographic Encoding Schemes for Cards
There are two different encoding schemes that can be used
for the digital representation of playing cards. In the
scheme of Schindelhauer@tie{}[Sc98] the type of a card is
shared among the players through bitwise representation
by quadratic (non-)residues. Thus the security relies on
the well-known Quadratic Residuosity Assumption (QRA).
Unfortunately, the size of a card grows linearly in the
number of players and logarithmically in the number of
different card types. Recently the much more efficient
solution of Barnett and Smart@tie{}[BS03] has been
implemented. This encoding works in a cyclic group of
prime order and requires that the Decisional
Diffie-Hellman Assumption (DDH) holds.

Because of the reduced computational and communication
complexity (cf.@tie{}[St05]) the usage of the second card
encoding scheme (@code{VTMF_Card}) is highly recommended.

@deftp {Data type} TMCG_Card
This @code{struct} represents a card in the encoding scheme
of Schindelhauer@tie{}[Sc98]. The type of the card is shared
among the players by quadratic residues and non-residues,
respectively. The security relies on the Quadratic Residuosity
Assumption.

	@deftypecv {Member} TMCG_Card @code{std::vector< std::vector<MP_INT> >} z
	This @math{k\times w}-matrix encodes the type of the
	corresponding card in a shared manner. For each of the
	@math{k} players there is a separate row and for each of
	the @math{w} bits in the binary representation of the
	type there is a column. The elements are numbers from
	the group @math{{\bf Z}^{\circ}_{m_i}} where @math{m_i}
	is the public modul of the @math{i}th player.
	@end deftypecv
	
	@defop {Constructor} TMCG_Card TMCG_Card ()
	This default constructor initalizes the card with a
	@math{1\times 1}-matrix. Later the method
	@code{TMCG_Card::resize} can be used to enlarge the
	card representation.
	@end defop
	
	@defop {Constructor} TMCG_Card TMCG_Card (@code{size_t} k, @code{size_t} w)
	This constructor initalizes the card with a @math{k\times w}-matrix.
	The parameter @var{k} is the number of players and @var{w} is the
	number of bits used in the binary representation of the card type.
	@end defop
	
	@defop {Constructor} TMCG_Card TMCG_Card (@code{const TMCG_Card} &that)
	@end defop
	
@end deftp

@deftp {Data type} VTMF_Card
xyz
@end deftp

@deftp {Data type} TMCG_CardSecret
uvw
@end deftp

@deftp {Data type} VTMF_CardSecret
hij
@end deftp

@subsubsection Cryptographic Keys


@subsection Classes

@chapter Examples
You should have a look at the several examples in the directory
@file{tests} and read the commented source code. A detailed
exposition will later be included here.


@c **********************************************************
@c *******************  Appendices  *************************
@c **********************************************************
@include gpl.texi
@include fdl.texi

@unnumbered General Index
@printindex cp

@unnumbered API Index
@printindex fn

@bye
