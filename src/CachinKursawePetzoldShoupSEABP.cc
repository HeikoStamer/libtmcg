/*******************************************************************************
  CachinKursawePetzoldShoupSEABP.cc,
              |S|ecure and |E|fficient |A|synchronous |B|roadcast |P|rotocols

     [CKPS01] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup:
       'Secure and Efficient Asynchronous Broadcast Protocols',
     Proceedings of CRYPTO 2001, LNCS 2139, pp. 524--541, Springer 2001.
     Full length version of extended abstract: http://shoup.net/papers/ckps.pdf

   This file is part of LibTMCG.

 Copyright (C) 2016, 2017, 2018, 2019  Heiko Stamer <HeikoStamer@gmx.net>

   LibTMCG is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   LibTMCG is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with LibTMCG; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
*******************************************************************************/

// include headers
#ifdef HAVE_CONFIG_H
	#include "libTMCG_config.h"
#endif
#include "CachinKursawePetzoldShoupSEABP.hh"

// additional headers
#include <iostream>
#include <sstream>
#include <utility>
#include <algorithm>
#include <stdexcept>
#include "mpz_srandom.hh"
#include "mpz_helper.hh"
#include "mpz_shash.hh"
#include "aiounicast.hh"

CachinKursawePetzoldShoupRBC::CachinKursawePetzoldShoupRBC
	(const size_t n_in, const size_t t_in, const size_t j_in,
	aiounicast *aiou_in, const size_t scheduler_in,
	const time_t timeout_in, const size_t fifo_skip_in):
		aio_timeout_vs(aiou_in->aio_timeout_very_short), // timeout for sending
		fifo_skip(fifo_skip_in), fifo(true)
{
	if (t_in > n_in)
		throw std::invalid_argument("RBC: t > n");
	if (j_in >= n_in)
		throw std::invalid_argument("RBC: j >= n");

	// initialize basic parameters
	n = n_in, t = t_in, j = j_in;

	// checking maximum asynchronous t-resilience
	if ((3 * t) >= n)
	{
		std::cerr << "RBC(" << j << ") WARNING: maximum asynchronous " <<
			"t-resilience exceeded" << std::endl;
	}
	// checking minimum number of parties
	if (n < 2)
	{
		std::cerr << "RBC(" << j << ") WARNING: more than one party needed; " <<
			"RBC will not work" << std::endl;
		throw std::invalid_argument("RBC: n < 2");
	}

	// initialize asynchonous unicast
	aio_default_scheduler = scheduler_in;
	aio_default_timeout = timeout_in;
	aiou = aiou_in;

	// initialize ID and log
	mpz_init_set_ui(ID, 0UL);
	ID_log["0"] = "entry generated by constructor";

	// initialize whoami (this variable is called $j$ in the paper)
	mpz_init_set_ui(whoami, j);

	// initialize sequence counter
	mpz_init_set_ui(s, 0UL);

	// initialize message action types
	mpz_init_set_ui(r_send, 1UL);
	mpz_init_set_ui(r_echo, 2UL);
	mpz_init_set_ui(r_ready, 3UL);
	mpz_init_set_ui(r_request, 4UL);
	mpz_init_set_ui(r_answer, 5UL);
	mpz_init_set_ui(l_retrieve, 6UL);
	mpz_init_set_ui(l_deliver, 7UL);
	mpz_init_set_ui(l_fail, 8UL);

	// initialize message counters
	send.resize(n);
	echo.resize(n);
	ready.resize(n);
	request.resize(n);
	answer.resize(n);
	retrieve.resize(n);
	deliver.resize(n);

	// initialize message and deliver buffers
	buf_mpz.resize(n);
	buf_id.resize(n);
	buf_msg.resize(n);
	for (size_t i = 0; i < n; i++)
	{
		deliver_error.push_back(false);
		mpz_ptr tmp = new mpz_t();
		mpz_init_set_ui(tmp, 1UL); // initialize sequence counter by 1
		deliver_s.push_back(tmp);
	}
}

void CachinKursawePetzoldShoupRBC::setID
	(const std::string &ID_in, const bool fifo_in)
{
	// save the last ID
	mpz_ptr tmp1 = new mpz_t();
	mpz_init_set(tmp1, ID);
	last_IDs.push_back(tmp1);

	// save the last sequence counter
	mpz_ptr tmp2 = new mpz_t();
	mpz_init_set(tmp2, s);
	last_s.push_back(tmp2);

	// save deliver sequence counters
	last_deliver_s.resize(last_deliver_s.size() + 1);
	for (size_t i = 0; i < n; i++)
	{
		mpz_ptr tmp3 = new mpz_t();
		mpz_init_set(tmp3, deliver_s[i]);
		(last_deliver_s.back()).push_back(tmp3);
	}

	// set new ID and FIFO flag
	std::stringstream myID, str_ID, mylog;
	myID << "CachinKursawePetzoldShoupRBC called from [" << ID_in << "]" <<
		" with last ID = " << ID;
	tmcg_mpz_shash(ID, myID.str());
	fifo = fifo_in;
	str_ID << ID;
	mylog << "setID(" << (fifo ? "true" : "false") << ") -> " << myID.str();
	ID_log[str_ID.str()] = mylog.str();

	// reset sequence counter
	mpz_set_ui(s, 0UL);

	// reset deliver sequence counters
	for (size_t i = 0; i < n; i++)
		mpz_set_ui(deliver_s[i], 1UL);
}

void CachinKursawePetzoldShoupRBC::recoverID
	(const std::string &ID_in, const bool fifo_in)
{
	// save the last ID
	mpz_ptr tmp1 = new mpz_t();
	mpz_init_set(tmp1, ID);
	last_IDs.push_back(tmp1);

	// save the last sequence counter
	mpz_ptr tmp2 = new mpz_t();
	mpz_init_set(tmp2, s);
	last_s.push_back(tmp2);

	// save deliver sequence counters
	last_deliver_s.resize(last_deliver_s.size() + 1);
	for (size_t i = 0; i < n; i++)
	{
		mpz_ptr tmp3 = new mpz_t();
		mpz_init_set(tmp3, deliver_s[i]);
		(last_deliver_s.back()).push_back(tmp3);
	}

	// set new ID and FIFO flag
	std::stringstream myID, str_ID, mylog;
	myID << "CachinKursawePetzoldShoupRBC called from [" << ID_in << "]" <<
		" with last ID = " << ID;
	tmcg_mpz_shash(ID, myID.str());
	fifo = fifo_in;
	str_ID << ID;
	mylog << "recoverID(" << (fifo ? "true" : "false") << ") -> " << myID.str();
	ID_log[str_ID.str()] = mylog.str();

	// recover sequence counter, if available
	if (recover_s.count(str_ID.str()) > 0)
		mpz_set(s, recover_s[str_ID.str()]);
	else
		mpz_set_ui(s, 0UL);

	// recover deliver sequence counters, if available
	for (size_t i = 0; i < n; i++)
	{
		if (recover_deliver_s.count(str_ID.str()) > 0)
		{
			if (recover_deliver_s[str_ID.str()].size() == n)
				mpz_set(deliver_s[i], (recover_deliver_s[str_ID.str()])[i]);
			else
				mpz_set_ui(deliver_s[i], 1UL);
		}
		else
			mpz_set_ui(deliver_s[i], 1UL);
	}
}

void CachinKursawePetzoldShoupRBC::unsetID
	(const bool fifo_in)
{
	fifo = fifo_in;
	std::stringstream str_ID, mylog;
	str_ID << ID;
	mylog << "unsetID(" << (fifo ? "true" : "false") << ") -> " <<
		ID_log[str_ID.str()];
	ID_log[str_ID.str()] = mylog.str();

	// save current sequence counter for recovery
	if (recover_s.count(str_ID.str()) == 0)
	{
		mpz_ptr tmp1 = new mpz_t();
		mpz_init_set(tmp1, s);
		recover_s[str_ID.str()] = tmp1;
	}
	else
		mpz_set(recover_s[str_ID.str()], s);

	// save current deliver sequence counters for recovery
	if (recover_deliver_s.count(str_ID.str()) == 0)
	{
		recover_deliver_s[str_ID.str()].resize(n);
		for (size_t i = 0; i < n; i++)
		{
			mpz_ptr tmp3 = new mpz_t();
			mpz_init_set(tmp3, deliver_s[i]);
			(recover_deliver_s[str_ID.str()])[i] = tmp3;
		}
	}
	else
	{
		recover_deliver_s[str_ID.str()].resize(n);
		for (size_t i = 0; i < n; i++)
			mpz_set((recover_deliver_s[str_ID.str()])[i] , deliver_s[i]);
	}

	// set last ID, if available
	if (!last_IDs.empty())
	{
		mpz_ptr tmp = last_IDs.back();
		mpz_set(ID, tmp);
		mpz_clear(tmp);
		delete [] tmp;
		last_IDs.pop_back();
	}
	else
		mpz_set_ui(ID, 0UL);

	// set last sequence counter, if available
	if (!last_s.empty())
	{
		mpz_ptr tmp = last_s.back();
		mpz_set(s, tmp);
		mpz_clear(tmp);
		delete [] tmp;
		last_s.pop_back();
	}
	else
		mpz_set_ui(s, 0UL);

	// set last deliver sequence counters, if available
	if (!last_deliver_s.empty())
	{
		std::vector<mpz_ptr> vtmp = last_deliver_s.back();
		for (size_t i = 0; i < n; i++)
		{
			mpz_set(deliver_s[i], vtmp[i]);
			mpz_clear(vtmp[i]);
			delete [] vtmp[i];
		}
		last_deliver_s.pop_back();
	}
	else
	{
		for (size_t i = 0; i < n; i++)
			mpz_set_ui(deliver_s[i], 1UL);
	}
}

void CachinKursawePetzoldShoupRBC::InitializeMessage
	(RBC_Message &message)
{
	for (size_t mm = 0; mm < 5; mm++)
	{
		mpz_ptr tmp = new mpz_t();
		mpz_init(tmp);
		message.push_back(tmp);
	}
}

void CachinKursawePetzoldShoupRBC::InitializeMessage
	(RBC_Message &message, const RBC_ConstMessage &source)
{
	if (source.size() != 5)
		throw std::invalid_argument("RBC::InitializeMessage(): bad message");
	InitializeMessage(message);
	for (size_t mm = 0; mm < source.size(); mm++)
		mpz_set(message[mm], source[mm]);
}

void CachinKursawePetzoldShoupRBC::InitializeMessage
	(RBC_Message &message, const RBC_Message &source)
{
	if (source.size() != 5)
		throw std::invalid_argument("RBC::InitializeMessage(): bad message");
	InitializeMessage(message);
	for (size_t mm = 0; mm < source.size(); mm++)
		mpz_set(message[mm], source[mm]);
}

void CachinKursawePetzoldShoupRBC::AssignMessage
	(RBC_ConstMessage &message, const RBC_Message &source)
{
	if (source.size() != 5)
		throw std::invalid_argument("RBC::AssignMessage(): bad message");
	message.clear();
	for (size_t mm = 0; mm < source.size(); mm++)
		message.push_back(source[mm]);
}

void CachinKursawePetzoldShoupRBC::TagMessage
	(std::string &tag, const RBC_Message &message)
{
	if (message.size() != 5)
		throw std::invalid_argument("RBC::TagMessage(): bad message");
	mpz_t tag_val;
	mpz_init(tag_val);
	tmcg_mpz_shash(tag_val, 3, message[0], message[1], message[2]);
	std::stringstream tag_ss;
	tag_ss << tag_val;
	tag = tag_ss.str();
	mpz_clear(tag_val);
}

void CachinKursawePetzoldShoupRBC::TagMessage
	(std::string &tag, const RBC_ConstMessage &message)
{
	if (message.size() != 5)
		throw std::invalid_argument("RBC::TagMessage(): bad message");
	mpz_t tag_val;
	mpz_init(tag_val);
	tmcg_mpz_shash(tag_val, 3, message[0], message[1], message[2]);
	std::stringstream tag_ss;
	tag_ss << tag_val;
	tag = tag_ss.str();
	mpz_clear(tag_val);
}

void CachinKursawePetzoldShoupRBC::ReleaseMessage
	(RBC_Message &message)
{
	for (size_t mm = 0; mm < message.size(); mm++)
	{
		mpz_clear(message[mm]);
		delete [] message[mm];
	}
	message.clear();
}

void CachinKursawePetzoldShoupRBC::Broadcast
	(mpz_srcptr m, const bool simulate_faulty_behaviour)
{
	if (fifo)
		mpz_add_ui(s, s, 1UL); // increase sequence counter
	else
		tmcg_mpz_wrandomb(s, 256); // choose random 256-bit value

	// prepare message $(ID.j.s, r-send, m)$
	RBC_ConstMessage message;
	message.push_back(ID);
	message.push_back(whoami);
	message.push_back(s);
	message.push_back(r_send);
	message.push_back(m);

	// initialize and copy the prepared message
	RBC_Message modified_message;
	InitializeMessage(modified_message, message);

	// send message to all parties (very short timeout)
	for (size_t i = 0; i < n; i++)
	{
		size_t simulate_faulty_randomizer = tmcg_mpz_wrandom_ui() % n; // p. 1/n
		size_t simulate_faulty_randomizer1 = tmcg_mpz_wrandom_ui() % 2;
		size_t simulate_faulty_randomizer2 = tmcg_mpz_wrandom_ui() % 2;
		size_t simulate_faulty_randomizer3 = tmcg_mpz_wrandom_ui() % 2;
		size_t simulate_faulty_randomizer4 = tmcg_mpz_wrandom_ui() % 2;
		if (simulate_faulty_behaviour && !simulate_faulty_randomizer &&
			simulate_faulty_randomizer1)
		{
			mpz_add_ui(modified_message[4], modified_message[4],
				1UL); // modify the payload
		}
		if (simulate_faulty_behaviour && !simulate_faulty_randomizer &&
			simulate_faulty_randomizer2)
		{
			mpz_add_ui(modified_message[1], modified_message[1],
				tmcg_mpz_wrandom_ui() % n); // modify the sender
		}
		if (simulate_faulty_behaviour && !simulate_faulty_randomizer &&
			simulate_faulty_randomizer3)
		{
			mpz_add_ui(modified_message[2], modified_message[2],
				tmcg_mpz_wrandom_ui() % 5); // modify the sequence counter
		}
		AssignMessage(message, modified_message); // assign the modified message
		if (simulate_faulty_behaviour && !simulate_faulty_randomizer &&
			simulate_faulty_randomizer4)
		{
			size_t r = tmcg_mpz_wrandom_ui() % n;
			if (!aiou->Send(message, r, aio_timeout_vs))
			{
				std::cerr << "RBC(" << j << "): sending r-send failed for " <<
					"random party " << r << std::endl;
			}
		}
		else
		{
			if (!aiou->Send(message, i, aio_timeout_vs))
			{
				std::cerr << "RBC(" << j << "): sending r-send failed for " <<
					i << std::endl;
			}
		}
	}

	// release message
	ReleaseMessage(modified_message);
}

bool CachinKursawePetzoldShoupRBC::Deliver
	(mpz_ptr m, size_t &i_out,
	size_t scheduler, time_t timeout)
{
	// set aio default values
	if (scheduler == aiounicast::aio_scheduler_default)
		scheduler = aio_default_scheduler;
	if (timeout == aiounicast::aio_timeout_default)
		timeout = aio_default_timeout;
	// initialize foo
	mpz_t foo;
	mpz_init(foo);
	// initialize message $(ID.j.s, action, m)$
	RBC_Message message;
	InitializeMessage(message);
	// process messages according to the RBC protocol [CKPS01]
	// extended with a simple FIFO-order delivery mechanism
	// and a out-of-order handler for missing messages
	time_t entry_time = time(NULL);
	do
	{
		// first, process the deliver buffer
		std::list<RBC_VectorList::iterator> cleanup;
		std::map<size_t, RBC_VectorList::iterator> retrieve_it;
		mpz_t max_s[n+1], min_s[n+1]; // +1 to make scan-build happy
		for (size_t i = 0; i < n; i++)
		{
			mpz_init_set_ui(max_s[i], 0UL);
			mpz_init_set_ui(min_s[i], 0UL);
		}
		for (RBC_VectorList::iterator lit = deliver_buf.begin();
			lit != deliver_buf.end(); ++lit)
		{
			if (mpz_cmp((*lit)[0], ID))
				continue; // ID does not match; ignore for now
			size_t who = mpz_get_ui((*lit)[1]);
			// check for matching deliver sequence counter
			if ((fifo && !mpz_cmp((*lit)[2], deliver_s[who])) || !fifo)
			{
				// compute hash of identifying tag $ID.j.s$
				std::string tag;
				TagMessage(tag, *lit);
				if (mbar.count(tag) == 0)
					throw std::runtime_error("RBC::Deliver(): mbar not found");
				// increase deliver sequence counter
				mpz_add_ui(deliver_s[who], deliver_s[who], 1UL);
				// get the payload from mbar cache
				mpz_set(m, mbar[tag]);
				i_out = who;
				// cleanup
				ReleaseMessage(*lit);
				deliver_buf.erase(lit);
				// release foo
				mpz_clear(foo);
				// release message
				ReleaseMessage(message);
				// release max_s and min_s
				for (size_t i = 0; i < n; i++)
				{
					mpz_clear(max_s[i]);
					mpz_clear(min_s[i]);
				}
				return true;
			}
			// check for greater deliver sequence counter
			bool gt_s = (mpz_cmp((*lit)[2], deliver_s[who]) > 0);
			if (fifo && gt_s)
			{
				if (!mpz_cmp_ui(max_s[who], 0UL) ||
					(mpz_cmp(max_s[who], (*lit)[2]) < 0))
				{
					mpz_set(max_s[who], (*lit)[2]);
				}
				if (!mpz_cmp_ui(min_s[who], 0UL) ||
					(mpz_cmp(min_s[who], (*lit)[2]) > 0))
				{
					mpz_set(min_s[who], (*lit)[2]);
					// retrieve always the minimal missing message
					if (retrieve_it.count(who) == 0)
					{
						retrieve_it[who] = lit;
					}
					else
					{
						retrieve_it.erase(who);
						retrieve_it[who] = lit;
					}
				}
			}
			// check for lower deliver sequence counter
			bool lt_s = (mpz_cmp((*lit)[2], deliver_s[who]) < 0);
			if (fifo && lt_s)
			{
				std::cerr << "RBC(" << j << "): remove obsolete message" <<
					" from " << who << " with s = " << (*lit)[2] << " (vs" <<
					" deliver_s = " << deliver_s[who] << ")" << std::endl;
				cleanup.push_back(lit);
			}
		}
		// skip FIFO ordering, if (max_s[i]-min_s[i]) > fifo_skip for some i
		for (size_t i = 0; (i < n) && fifo && (fifo_skip > 0); i++)
		{
			mpz_sub(foo, max_s[i], min_s[i]);
			if ((mpz_cmp_ui(foo, fifo_skip) > 0))
			{
				std::cerr << "RBC(" << j << "): adjust deliver sequence" <<
					" counter from " << deliver_s[i] << " to " <<
					min_s[i] << " for i = " << i << std::endl;
				deliver_error[i] = true; // ERROR: delivery out of order
				mpz_set(deliver_s[i], min_s[i]);
			}
		}
		// out-of-order handler: send l-retrieve messages to all other parties
		size_t cnt = 0, max = 40;
		for (std::map<size_t, RBC_VectorList::iterator>::const_iterator ci =
			retrieve_it.begin(); (ci != retrieve_it.end()) && fifo &&
			(fifo_skip == 0); ++ci)
		{
			size_t who = ci->first;
			mpz_set(foo, deliver_s[who]);
			while ((mpz_cmp(foo, min_s[who]) < 0) && (cnt < max))
			{
				RBC_ConstMessage message2;
				message2.push_back((*(ci->second))[0]);
				message2.push_back((*(ci->second))[1]);
				message2.push_back(foo);
				message2.push_back(l_retrieve);
				message2.push_back(l_retrieve);
				std::string tag;
				TagMessage(tag, message2);
				for (size_t i = 0; i < n; i++)
				{
					if (i == j)
						continue; // skip myself
					if (deliver[i].count(tag) > 0)
						continue; // skip, if already retrieved
					if (retrieve[i].count(tag) > 0)
						continue; // skip, if already sent
					if (!aiou->Send(message2, i, aio_timeout_vs))
					{
						std::cerr << "RBC(" << j << "): sending l-retrieve" <<
							" failed for " << i << std::endl;
					}
					else
					{
						std::cerr << "RBC(" << j << "): l-retrieve sent" <<
							" to " << i << " for message of party " <<
							who << " with s = " << foo <<
							" where min_s = " << min_s[who] << std::endl;
						retrieve[i].insert(std::pair<std::string, bool>(tag, true));
						cnt++;
					}
				}
				mpz_add_ui(foo, foo, 1UL);
			}
		}
		for (size_t i = 0; i < n; i++)
		{
			mpz_clear(max_s[i]);
			mpz_clear(min_s[i]);
		}
		// remove obsolete messages w.r.t. deliver sequence counter
		while (cleanup.size() > 0)
		{
			RBC_VectorList::iterator lit = cleanup.front();
			ReleaseMessage(*lit);
			deliver_buf.erase(lit);
			cleanup.pop_front();
		}
		// second, process anything buffered from previous calls/rounds
		size_t l = n;
		std::vector<size_t> pi;
		for (size_t i = 0; i < n; i++)
			pi.push_back(i);
		for (size_t i = 0; i < (n - 1); i++)
		{
			// create a random permutation to avoid DoS scenarios
			size_t tmp = pi[i];
			size_t rnd = i + (size_t)tmcg_mpz_wrandom_mod(n - i);
			pi[i] = pi[rnd];
			pi[rnd] = tmp;
		}
		for (size_t i = 0; i < pi.size(); i++)
		{
			if (buf_msg[pi[i]].size() >= message.size())
			{
				for (size_t mm = 0; mm < message.size(); mm++)
				{
					mpz_set(message[mm], buf_msg[pi[i]].front());
					mpz_clear(buf_msg[pi[i]].front());
					delete [] buf_msg[pi[i]].front();
					buf_msg[pi[i]].pop_front();
				}
				l = pi[i];
				break;
			}
		}
		// third, receive a new message, if nothing else is buffered
		if (l == n)
		{
			// receive a message from an arbitrary party $P_l$
			if (!aiou->Receive(message, l, scheduler, 0))
				continue; // next round
		}
		// compute hash of identifying tag $ID.j.s$
		std::string tag;
		TagMessage(tag, message);
		// discard and report misformed messages
		if ((mpz_cmp_ui(message[1], (n - 1)) > 0) ||
			(mpz_cmp_ui(message[1], 0) < 0))
		{
			std::cerr << "RBC(" << j << "): wrong j in tag from " << l <<
				std::endl;
			continue;
		}
		if (mpz_cmp_ui(message[2], 1UL) < 0)
		{
			std::cerr << "RBC(" << j << "): wrong s in tag from " << l <<
				std::endl;
			continue;
		}
		if ((mpz_cmp(message[3], r_send) < 0) ||
			(mpz_cmp(message[3], l_deliver) > 0))
		{
			std::cerr << "RBC(" << j << "): wrong action in tag from " << l <<
				std::endl;
			continue;
		}
		// upon receiving message $(ID.j.s, r-send, m)$ from $P_l$
		if (!mpz_cmp(message[3], r_send) && !send[l].count(tag))
		{
			send[l].insert(std::pair<std::string, bool>(tag, true));
			// if $(j = l)$ and $\bar{m} = \bot$ then
			if (mpz_cmp_ui(message[1], l))
			{
				std::cerr << "RBC(" << j << "): received faked r-send" <<
					" message of " << message[1] << " from " << l << std::endl;
				continue;
			}
			if (mbar.count(tag) == 0)
			{
				mpz_ptr tmp = new mpz_t();
				mpz_init_set(tmp, message[4]); // $\bar{m} \gets m$
				mbar.insert(std::pair<std::string, mpz_ptr>(tag, tmp));
			}
			else if (mpz_cmp(mbar[tag], message[4]))
			{
				std::cerr << "RBC(" << j << "): received bad r-send" <<
					" message from " << l << std::endl;
				continue;
			}
			// prepare message $(ID.j.s, r-echo, H(m))$
			RBC_ConstMessage message2;
			message2.push_back(message[0]);
			message2.push_back(message[1]);
			message2.push_back(message[2]);
			message2.push_back(r_echo);
			tmcg_mpz_shash(message[4], 1, message[4]);
			message2.push_back(message[4]);
			// send r-echo to all parties (very short timeout)
			for (size_t i = 0; i < n; i++)
			{
				if (!aiou->Send(message2, i, aio_timeout_vs))
				{
					std::cerr << "RBC(" << j << "): sending r-echo" <<
						" failed for " << i << std::endl;
				}
			}
			message2.clear();
			continue;
		}
		else if (!mpz_cmp(message[3], r_send) && send[l].count(tag))
		{
			std::cerr << "RBC(" << j << "): received r-send for same tag" <<
				" more than once from " << l << std::endl;
			continue;
		}
		// upon receiving message $(ID.j.s, r-echo, d)$ from $P_l$ for the first time
		if (!mpz_cmp(message[3], r_echo) && !echo[l].count(tag))
		{
//std::cerr << "RBC: r-echo from " << l << " with d = " << message[4] << std::endl;
			echo[l].insert(std::pair<std::string, bool>(tag, true));
			std::stringstream d_ss;
			d_ss << message[4];
			std::string d_string = d_ss.str();
			if (d_string.length() > (2 * tag.length()))
			{
				std::cerr << "RBC(" << j << "): size of d exceeded in r-echo" <<
					" from " << l << std::endl;
				continue;
			}
			if (e_d.find(tag) == e_d.end())
			{
				RBC_TagCount mmm;
				e_d.insert(std::pair<std::string, RBC_TagCount>(tag, mmm));
			}
			RBC_TagCount::iterator eit = e_d[tag].find(d_string);
			if (eit == e_d[tag].end())
			{
				eit = (e_d[tag].insert(
					std::pair<std::string, size_t>(d_string, 1))).first; // = 1
			}
			else
				(*eit).second++;
			if (r_d.find(tag) == r_d.end())
			{
				RBC_TagCount mmm;
				r_d.insert(std::pair<std::string, RBC_TagCount>(tag, mmm));
			}
			RBC_TagCount::iterator rit = r_d[tag].find(d_string);
			if (rit == r_d[tag].end())
			{
				rit = (r_d[tag].insert(
					std::pair<std::string, size_t>(d_string, 0))).first; // = 0
			}
			size_t r_d_tag = (*rit).second;
			size_t e_d_tag = (*eit).second;
//std::cerr << "RBC: [" << tag << "] r-echo with r_d = " << r_d_tag << " e_d = " << e_d_tag << std::endl;
			if ((e_d_tag == (n - t)) && (r_d_tag <= t))
			{
//std::cerr << "RBC(" << j << "): [" << tag << "] send r-ready message" << std::endl;
				// prepare message $(ID.j.s, r-ready, d)$
				RBC_ConstMessage message2;
				message2.push_back(message[0]);
				message2.push_back(message[1]);
				message2.push_back(message[2]);
				message2.push_back(r_ready);
				message2.push_back(message[4]);
				// send r-ready to all parties (very short timeout)
				for (size_t i = 0; i < n; i++)
				{
					if (!aiou->Send(message2, i, aio_timeout_vs))
					{
						std::cerr << "RBC(" << j << "): sending r-ready" <<
							" failed for " << i << std::endl;
					}
				}
				message2.clear();
			}
			continue;
		}
		else if (!mpz_cmp(message[3], r_echo) && echo[l].count(tag))
		{
			std::cerr << "RBC(" << j << "): received r-echo for same tag" <<
				" more than once from " << l << std::endl;
			continue;
		}
		// upon receiving message $(ID.j.s, r-ready, d)$ from $P_l$ for the first time
		if (!mpz_cmp(message[3], r_ready) && !ready[l].count(tag))
		{
//std::cerr << "RBC(" << j << "): [" << tag << "] r-ready from " << l << " with d = " << message[4] << std::endl;
			ready[l].insert(std::pair<std::string, bool>(tag, true));
			std::stringstream d_ss;
			d_ss << message[4];
			std::string d_string = d_ss.str();
			if (d_string.length() > (2 * tag.length()))
			{
				std::cerr << "RBC(" << j << "): size of d exceeded in" <<
					" r-ready from " << l << std::endl;
				continue;
			}
			if (e_d.find(tag) == e_d.end())
			{
				RBC_TagCount mmm;
				e_d.insert(std::pair<std::string, RBC_TagCount>(tag, mmm));
			}
			if (r_d.find(tag) == r_d.end())
			{
				RBC_TagCount mmm;
				r_d.insert(std::pair<std::string, RBC_TagCount>(tag, mmm));
			}
			RBC_TagCount::iterator rit = r_d[tag].find(d_string);
			if (rit == r_d[tag].end())
			{
				rit = (r_d[tag].insert(
					std::pair<std::string, size_t>(d_string, 1))).first; // = 1
			}
			else
				(*rit).second++;
			RBC_TagCount::iterator eit = e_d[tag].find(d_string);
			if (eit == e_d[tag].end())
			{
				eit = (e_d[tag].insert(
					std::pair<std::string, size_t>(d_string, 0))).first; // = 0
			}
			size_t r_d_tag = (*rit).second;
			size_t e_d_tag = (*eit).second;
//std::cerr << "RBC(" << j << "): [" << tag << "] r-ready with r_d = " << r_d_tag << " e_d = " << e_d_tag << std::endl;
			if ((t > 0) && (r_d_tag == (t + 1)) && (e_d_tag < (n - t)))
			{
				// prepare message $(ID.j.s, r-ready, d)$
				RBC_ConstMessage message2;
				message2.push_back(message[0]);
				message2.push_back(message[1]);
				message2.push_back(message[2]);
				message2.push_back(r_ready);
				message2.push_back(message[4]);
				// send r-ready to all parties (very short timeout)
				for (size_t i = 0; i < n; i++)
				{
					if (!aiou->Send(message2, i, aio_timeout_vs))
					{
						std::cerr << "RBC(" << j << "): sending r-ready" <<
							" failed for " << i << std::endl;
					}
				}
				message2.clear();
			}
			else if (r_d_tag == ((2 * t) + 1))
			{
				if (dbar.count(tag) == 0)
				{
					mpz_ptr tmp = new mpz_t();
					mpz_init_set(tmp, message[4]); // $\bar{d} \gets d$
					dbar.insert(std::pair<std::string, mpz_ptr>(tag, tmp));
				}
				else if (mpz_cmp(dbar[tag], message[4]))
				{
					std::cerr << "RBC(" << j << "): received bad r-ready" <<
						" message from " << l << std::endl;
					continue;
				}
				if (mbar.count(tag) == 0)
				{
					mpz_set_ui(foo, 0UL);
//std::cerr << "RBC: r-send not received yet for this tag by " << j << std::endl;
				}
				else
				{
					tmcg_mpz_shash(foo, 1, mbar[tag]);
				}
				if (mpz_cmp(foo, dbar[tag])) // $H(\bar{m}) \neq \bar{d}$
				{
					// prepare message $(ID.j.s, r-request)$
					RBC_ConstMessage message2;
					message2.push_back(message[0]);
					message2.push_back(message[1]);
					message2.push_back(message[2]);
					message2.push_back(r_request);
					message2.push_back(message[4]);
					// send r-request to some parties (very short timeout)
					size_t howmany = ((2 * t) + 1);
					for (size_t i = 0; i < howmany; i++)
					{
						if (!aiou->Send(message2, i, aio_timeout_vs))
						{
							std::cerr << "RBC(" << j << "): sending" <<
								" r-request failed for " << i << std::endl;
							if (howmany < n)
								howmany++; // increase request range
						}
					}
					message2.clear();
					continue; // waiting for r-answer is done in main loop
				}
//std::cerr << "RBC: deliver from " << mpz_get_ui(message[1]) << " m = " << mbar[tag] << std::endl;
				size_t who = mpz_get_ui(message[1]);
				if (who >= n)
					throw std::runtime_error("RBC::Deliver(): who >= n");
				// check for matching tag and sequence counter before delivering
				bool matching_tag = (mpz_cmp(message[0], ID) == 0);
				bool eq_s = (mpz_cmp(message[2], deliver_s[who]) == 0);
				if (matching_tag && ((fifo && eq_s) || !fifo))
				{
					if (mbar.count(tag) == 0)
						throw std::runtime_error("RBC::Deliver(): no mbar (r-ready)");
					mpz_set(m, mbar[tag]); // set the result to $\bar{m}$
					// increase sequence counter
					mpz_add_ui(deliver_s[who], deliver_s[who], 1L);
					i_out = who;
					// release foo
					mpz_clear(foo);
					// release message
					ReleaseMessage(message);
					return true;
				}
				if (matching_tag && fifo && !eq_s)
				{
					std::cerr << "RBC(" << j << "): WARNING - sequence" <<
						" counter does not match for " << who << " (" <<
						message[2] << " vs " << deliver_s[who] << ")" <<
						std::endl;
				}
				// buffer the acknowledged message for later delivery
				RBC_Message vtmp;
				InitializeMessage(vtmp, message);
				deliver_buf.push_back(vtmp);
//std::cerr << "RBC: P_" << j << " buffers deliver from " << who << " m = " << mbar[tag] << std::endl;
				continue;
			}
			continue;
		}
		else if (!mpz_cmp(message[3], r_ready) && ready[l].count(tag))
		{
			std::cerr << "RBC(" << j << "): received r-ready for same tag" <<
				" more than once from " << l << std::endl;
			continue;
		}
		// upon receiving message $(ID.j.s, r-request) from $P_l$ for the first time
		if (!mpz_cmp(message[3], r_request) && !request[l].count(tag))
		{
//std::cerr << "RBC(" << j << "): [" << tag << "] r-request from " << l << " with m = " << message[4] << std::endl;
			request[l].insert(std::pair<std::string, bool>(tag, true));
			if (mbar.count(tag) > 0)
			{
				// prepare message $(ID.j.s, r-answer, \bar{m})$
				RBC_ConstMessage message2;
				message2.push_back(message[0]);
				message2.push_back(message[1]);
				message2.push_back(message[2]);
				message2.push_back(r_answer);
				message2.push_back(mbar[tag]);
				// send only to requesting party by unicast transmission (very short timeout)
				if (!aiou->Send(message2, l, aio_timeout_vs))
				{
					std::cerr << "RBC(" << j << "): sending r-answer failed" <<
						" for " << l << std::endl;
				}
				message2.clear();
			}
			continue;
		}
		else if (!mpz_cmp(message[3], r_request) && request[l].count(tag))
		{
			std::cerr << "RBC(" << j << "): received r-request for same tag" <<
				" more than once from " << l << std::endl;
			continue;
		}
		// upon receiving message $(ID.j.s, r-answer, m)$ from $P_l$ for the first time
		if (!mpz_cmp(message[3], r_answer) && !answer[l].count(tag))
		{
//std::cerr << "RBC(" << j << "): [" << tag << "] r-answer from " << l << " with m = " << message[4] << std::endl;
			answer[l].insert(std::pair<std::string, bool>(tag, true));
			if (dbar.count(tag) == 0)
			{
				std::cerr << "RBC(" << j << "): not ready for processing" <<
					" r-answer from " << l << std::endl;
				continue;
			}
			tmcg_mpz_shash(foo, 1, message[4]); // compute $H(m)$
			if (!mpz_cmp(foo, dbar[tag]))
			{
				if (mbar.count(tag) == 0)
				{
					mpz_ptr tmp = new mpz_t();
					mpz_init(tmp);
					mbar.insert(std::pair<std::string, mpz_ptr>(tag, tmp));
					mpz_set(mbar[tag], message[4]); // $\bar{m} \gets m$
				}
				else 
					mpz_set(mbar[tag], message[4]);
			}
			else
			{
				std::cerr << "RBC(" << j << "): bad r-answer from " <<
					l << std::endl;
				continue;
			}
//std::cerr << "RBC: deliver from " << mpz_get_ui(message[1]) << " m = " << mbar[tag] << std::endl;
			size_t who = mpz_get_ui(message[1]);
			if (who >= n)
				throw std::runtime_error("RBC::Deliver(): who >= n");
			// check for matching tag and sequence counter before delivering
			bool matching_tag = (mpz_cmp(message[0], ID) == 0);
			bool eq_s = (mpz_cmp(message[2], deliver_s[who]) == 0);
			if (matching_tag && ((fifo && eq_s) || !fifo))
			{
				if (mbar.count(tag) == 0)
					throw std::runtime_error("RBC::Deliver(): no mbar (r-answer)");
				// get the playload from mbar cache
				mpz_set(m, mbar[tag]);
				// increase sequence counter
				mpz_add_ui(deliver_s[who], deliver_s[who], 1L);
				i_out = who;
				// release foo
				mpz_clear(foo);
				// release message
				ReleaseMessage(message);
				return true;
			}
			if (matching_tag && fifo && !eq_s)
			{
				std::cerr << "RBC(" << j << "): WARNING - sequence counter" <<
					" does not match for " << who << " (" << message[2] <<
						" vs " << deliver_s[who] << ")" << std::endl;
			}
			// buffer the acknowledged message for later delivery
			RBC_Message vtmp;
			InitializeMessage(vtmp, message);
			deliver_buf.push_back(vtmp);
			continue;
		}
		else if (!mpz_cmp(message[3], r_answer) && answer[l].count(tag))
		{
			std::cerr << "RBC(" << j << "): received r-answer for same tag" <<
				" more than once from " << l << std::endl;
			continue;
		}
		// upon receiving message $(ID.j.s, l-retrieve)$ from $P_l$
		if (!mpz_cmp(message[3], l_retrieve))
		{
std::cerr << "RBC(" << j << "): [" << tag << "] l-retrieve from " << l << std::endl;
			size_t who = mpz_get_ui(message[1]);
			if (who >= n)
				throw std::runtime_error("RBC::Deliver(): who >= n");
			bool gt_s = (mpz_cmp(message[2], deliver_s[who]) < 0);
			if ((mbar.count(tag) > 0) && ((fifo && gt_s) || !fifo))
			{
				// prepare message $(ID.j.s, l-deliver, \bar{m})$
				RBC_ConstMessage message2;
				message2.push_back(message[0]);
				message2.push_back(message[1]);
				message2.push_back(message[2]);
				message2.push_back(l_deliver);
				message2.push_back(mbar[tag]);
				// send l-deliver only to requesting party (very short timeout)
				if (!aiou->Send(message2, l, aio_timeout_vs))
				{
					std::cerr << "RBC(" << j << "): sending l-deliver failed" <<
						" for " << l << std::endl;
				}
				message2.clear();
			}
			else
			{
				// prepare message $(ID.j.s, l-fail, l-fail)$
				RBC_ConstMessage message2;
				message2.push_back(message[0]);
				message2.push_back(message[1]);
				message2.push_back(message[2]);
				message2.push_back(l_fail);
				message2.push_back(l_fail);
				// send l-fail only to requesting party (very short timeout)
				if (!aiou->Send(message2, l, aio_timeout_vs))
				{
					std::cerr << "RBC(" << j << "): sending l-fail failed" <<
						" for " << l << std::endl;
				}
				message2.clear();
			}
			continue;
		}
		// upon receiving message $(ID.j.s, l-deliver, m)$ from $P_l$ for the first time
		if (!mpz_cmp(message[3], l_deliver) && !deliver[l].count(tag))
		{
std::cerr << "RBC(" << j << "): [" << tag << "] l-deliver from " << l << std::endl;
			if (!retrieve[l].count(tag))
			{
				std::cerr << "RBC(" << j << "): received l-deliver for" <<
					" unwanted tag from " << l << std::endl;
				continue;
			}
			deliver[l].insert(std::pair<std::string, bool>(tag, true));
			if (retrieve_buf.count(tag) == 0)
			{
				retrieve_buf[tag].resize(n);
				for (size_t i = 0; i < n; i++)
				{
					mpz_ptr tmp = new mpz_t();
					mpz_init_set_ui(tmp, 0UL);
					(retrieve_buf[tag])[i] = tmp;
				}
			}
			mpz_set((retrieve_buf[tag])[l], message[4]); // buffer content
			size_t deliver_num = 0;
			for (size_t i = 0; i < n; i++)
			{
				if (deliver[i].count(tag))
					deliver_num++;
			}
			if (deliver_num < (n - t))
				continue; // skip delivery, if not enough messages retrieved
			for (size_t i = 0; i < n; i++)
			{
				size_t agree_num = 1;
				if (!deliver[i].count(tag) || (i == j))
					continue; // skip wrong parties
				mpz_ptr agree_val = (retrieve_buf[tag])[i];
				for (size_t k = i + 1; k < n; k++)
				{
					if (!deliver[k].count(tag) || (k == j))
						continue; // skip wrong parties
					if (!mpz_cmp(agree_val, (retrieve_buf[tag])[k]))
						agree_num++;
				}
				if (agree_num >= (n - t))
				{
					size_t who = mpz_get_ui(message[1]);
					if (who >= n)
						throw std::runtime_error("RBC::Deliver(): who >= n");
					if (mbar.count(tag) == 0)
					{
						mpz_ptr tmp = new mpz_t();
						mpz_init(tmp);
						mbar.insert(std::pair<std::string, mpz_ptr>(tag, tmp));
						mpz_set(mbar[tag], (retrieve_buf[tag])[i]);
					}
					else 
						mpz_set(mbar[tag], (retrieve_buf[tag])[i]);
					std::cerr << "RBC(" << j << "): out-of-order handler" <<
						" successfully retrieved m = " << mbar[tag] << " for" <<
						" party " << who << " with s = " << message[2] <<
						std::endl;
					// check for matching tag and sequence counter
					bool matching_tag = (mpz_cmp(message[0], ID) == 0);
					bool eq_s = (mpz_cmp(message[2], deliver_s[who]) == 0);
					if (matching_tag && ((fifo && eq_s) || !fifo))
					{
						// get the payload from agreed value
						mpz_set(m, mbar[tag]);
						// increase sequence counter
						mpz_add_ui(deliver_s[who], deliver_s[who], 1L);
						i_out = who;
						// release foo
						mpz_clear(foo);
						// release message
						ReleaseMessage(message);
						return true;
					}
					if (matching_tag && fifo && !eq_s)
					{
						std::cerr << "RBC(" << j << "): WARNING - sequence" <<
							" counter does not match for " << who << " (" <<
							message[2] << " vs " << deliver_s[who] << ")" <<
							std::endl;
					}
					// buffer the acknowledged message for later delivery
					RBC_Message vtmp;
					InitializeMessage(vtmp, message);
					deliver_buf.push_back(vtmp);
					break;
				}
			}
			continue;
		}
		else if (!mpz_cmp(message[3], l_deliver) && deliver[l].count(tag))
		{
			std::cerr << "RBC(" << j << "): received l-deliver for same tag" <<
				" more than once from " << l << std::endl;
			continue;
		}
		// upon receiving message $(ID.j.s, l-fail, l-fail)$ from $P_l$
		if (!mpz_cmp(message[3], l_fail))
		{
std::cerr << "RBC(" << j << "): [" << tag << "] l-fail from " << l << std::endl;
			if (deliver[l].count(tag) > 0)
				continue;
			// retry by sending l-retrieve again
			if (retrieve[l].count(tag) > 0)
				retrieve[l].erase(tag);
			continue;
		}

		// report on discarded messages
		std::cerr << "RBC(" << j << "): WARNING - discard message of" <<
			" action = " << message[3] << " from " << l << std::endl;
	}
	while (time(NULL) < (entry_time + timeout));
	i_out = n; // timeout for all parties
	// release foo
	mpz_clear(foo);
	// release message
	ReleaseMessage(message);
	return false;
}

bool CachinKursawePetzoldShoupRBC::DeliverFrom
	(mpz_ptr m, const size_t i_in,
	size_t scheduler, time_t timeout)
{
	// sanity check
	if (i_in >= n)
	{
		std::cerr << "RBC(" << j << "): DeliverFrom() with " << i_in <<
			" >= " << n << std::endl;
		return false; // FIXME: throw exception
	}
	// set aio default values
	if (scheduler == aiounicast::aio_scheduler_default)
		scheduler = aio_default_scheduler;
	if (timeout == aiounicast::aio_timeout_default)
		timeout = aio_default_timeout;
	time_t entry_time = time(NULL);
	do
	{
		// anything buffered?
		if ((buf_mpz[i_in].size() > 0) && (buf_id[i_in].size() > 0))
		{
			for (RBC_BufferList::iterator lit = buf_mpz[i_in].begin(),
				litid = buf_id[i_in].begin();
				((lit != buf_mpz[i_in].end()) && (litid != buf_id[i_in].end()));
				++lit, ++litid)
			{
				if (!mpz_cmp(*litid, ID))
				{
					mpz_set(m, *lit);
					mpz_clear(*lit), mpz_clear(*litid);
					delete [] *lit, delete [] *litid;
					buf_mpz[i_in].erase(lit), buf_id[i_in].erase(litid);
					return true;
				}
			}
		}
		else
		{
			// store mpz at the end of corresponding buffer
			size_t l;
			mpz_ptr tmp = new mpz_t(), tmpID = new mpz_t();
			mpz_init(tmp), mpz_init_set(tmpID, ID);
			if (Deliver(tmp, l, scheduler, 0))
			{
				buf_mpz[l].push_back(tmp);
				buf_id[l].push_back(tmpID);
			}
			else
			{
				mpz_clear(tmp), mpz_clear(tmpID);
				delete [] tmp, delete [] tmpID;
			}
		}
	}
	while (time(NULL) < (entry_time + timeout));
	if (i_in != j)
	{
		std::cerr << "RBC(" << j << "): timeout delivering from " <<
			i_in << std::endl;
	}
	return false;
}

void CachinKursawePetzoldShoupRBC::QueueFrom
	(mpz_srcptr m, const size_t i_in)
{
	// sanity check
	if (i_in >= n)
	{
		std::cerr << "RBC(" << j << "): QueueFrom() with " << i_in <<
			" >= " << n << std::endl;
		return; // FIXME: throw exception
	}
	// store mpz at the front of corresponding buffer
	mpz_ptr tmp = new mpz_t(), tmpID = new mpz_t();
	mpz_init_set(tmp, m), mpz_init_set(tmpID, ID);
	buf_mpz[i_in].insert(buf_mpz[i_in].begin(), tmp);
	buf_id[i_in].insert(buf_id[i_in].begin(), tmpID);
}

bool CachinKursawePetzoldShoupRBC::Sync
	(time_t timeout, const std::string tag)
{
	// set aio default values w.r.t. number of potentially corrupted parties
	if (timeout == aiounicast::aio_timeout_default)
		timeout = (t + 1) * aio_default_timeout;
	else
		timeout *= (t + 1);
	// set common channel ID for synchronization messages
	std::stringstream myID;
	myID << "CachinKursawePetzoldShoupRBC::Sync(" <<
		timeout << ", " << tag << ")";
	setID(myID.str());
	// initialize
	time_t max_timeout = timeout;
	time_t slice_timeout = (timeout / sync_slices) + 1;
	time_t entry_time = time(NULL);
	long int last_diff = 42424242;
	mpz_t mtv;
	mpz_init(mtv);
	do
	{
		time_t slice_entry_time = time(NULL);
		time_t rest = 0;
		if (timeout > (slice_entry_time - entry_time))
		{
			rest = timeout - (slice_entry_time - entry_time);
			mpz_set_ui(mtv, rest);
			Broadcast(mtv);
		}
		else
			break;
		std::map<size_t, time_t> tvs;
		tvs[j] = rest;
		do
		{
			size_t l;
			if (Deliver(mtv, l, aio_default_scheduler, 0))
			{
				time_t utv;
				utv = (time_t)mpz_get_ui(mtv);
				if (utv <= max_timeout)
				{
					tvs[l] = utv;
				}
				else
				{
					std::cerr << "RBC(" << j << "): bad sync timestamp " <<
						utv << " received from " << l << std::endl;
				}
			}
		}
		while (time(NULL) < (slice_entry_time + slice_timeout));
		std::vector<time_t> vtvs;
		for (std::map<size_t, time_t>::const_iterator ti = tvs.begin();
			ti != tvs.end(); ++ti)
		{
			vtvs.push_back(ti->second);
		}
		std::sort(vtvs.begin(), vtvs.end());
		if (vtvs.size() < (n - t))
		{
			std::cerr << "RBC(" << j << "): WARNING - not enough sync" <<
				" timestamps received" << std::endl;
		}
		else
		{
			// use a median value as some kind of gentle agreement
			time_t median_timeout = vtvs[vtvs.size()/2];
			time_t slice_diff = (slice_entry_time - entry_time);
			long int diff = median_timeout - (timeout - slice_diff);
			last_diff = diff;
			if (std::abs(diff) > 0)
			{
				std::cerr << "RBC(" << j << "): sync diff = " <<
					diff << std::endl;
			}
			if (std::abs(diff) <= max_timeout)
			{
				timeout += diff;
			}
			else
			{
				std::cerr << "RBC(" << j << "): time jump detected with" <<
					" diff = " << diff << std::endl;
			}
		}
	}
	while (time(NULL) < (entry_time + timeout));
	// release
	mpz_clear(mtv);
	unsetID();
	if (std::abs(last_diff) <= slice_timeout)
	{
		return true;
	}
	else
	{
		std::cerr << "RBC(" << j << "): synchroniziation failed with" <<
			" diff = " << last_diff << std::endl;
		return false;
	}
}

CachinKursawePetzoldShoupRBC::~CachinKursawePetzoldShoupRBC
	()
{
	mpz_clear(ID), mpz_clear(whoami), mpz_clear(s);
	for (RBC_BufferList::iterator lit = last_IDs.begin();
		lit != last_IDs.end(); ++lit)
	{
		mpz_clear(*lit);
		delete [] *lit;
	}
	last_IDs.clear();
	for (RBC_BufferList::iterator lit = last_s.begin();
		lit != last_s.end(); ++lit)
	{
		mpz_clear(*lit);
		delete [] *lit;
	}
	last_s.clear();
	for (RBC_VectorList::iterator lit = last_deliver_s.begin();
		lit != last_deliver_s.end(); ++lit)
	{
		for (size_t i = 0; i < lit->size(); i++)
		{
			mpz_clear((*lit)[i]);
			delete [] (*lit)[i];
		}
	}
	last_deliver_s.clear();
	for (RBC_BufferMap::iterator mit = recover_s.begin();
		mit != recover_s.end(); ++mit)
	{
		mpz_clear(mit->second);
		delete [] mit->second;
	}
	recover_s.clear();
	for (RBC_VectorMap::iterator mit = recover_deliver_s.begin();
		mit != recover_deliver_s.end(); ++mit)
	{
		for (size_t i = 0; i < (mit->second).size(); i++)
		{
			mpz_clear((mit->second)[i]);
			delete [] (mit->second)[i];
		}
	}
	recover_deliver_s.clear();
	mpz_clear(r_send);
	mpz_clear(r_echo);
	mpz_clear(r_ready);
	mpz_clear(r_request);
	mpz_clear(r_answer);
	mpz_clear(l_retrieve);
	mpz_clear(l_deliver);
	mpz_clear(l_fail);
	for (size_t i = 0; i < n; i++)
	{
		send[i].clear();
		echo[i].clear();
		ready[i].clear();
		request[i].clear();
		answer[i].clear();
		retrieve[i].clear();
		deliver[i].clear();
	}
	send.clear(), echo.clear(), ready.clear(), request.clear(), answer.clear();
	retrieve.clear(), deliver.clear();
	for (RBC_VectorMap::iterator mit = retrieve_buf.begin();
		mit != retrieve_buf.end(); ++mit)
	{
		for (size_t i = 0; i < (mit->second).size(); i++)
		{
			mpz_clear((mit->second)[i]);
			delete [] (mit->second)[i];
		}
	}
	retrieve_buf.clear();
	for (RBC_TagMpz::iterator mit = mbar.begin(); mit != mbar.end(); ++mit)
	{
		mpz_clear((*mit).second);
		delete [] (*mit).second;
	}
	mbar.clear();
	for (RBC_TagMpz::iterator mit = dbar.begin(); mit != dbar.end(); ++mit)
	{
		mpz_clear((*mit).second);
		delete [] (*mit).second;
	}
	dbar.clear();
	for (std::map<std::string, RBC_TagCount>::iterator mit = e_d.begin();
		mit != e_d.end(); ++mit)
	{
		((*mit).second).clear();
	}
	e_d.clear();
	for (std::map<std::string, RBC_TagCount>::iterator mit = r_d.begin();
		mit != r_d.end(); ++mit)
	{
		((*mit).second).clear();
	}	
	r_d.clear();
	for (size_t i = 0; i < n; i++)
	{
		for (RBC_BufferList::iterator lit = buf_mpz[i].begin();
			lit != buf_mpz[i].end(); ++lit)
		{
			mpz_clear(*lit);
			delete [] *lit;
		}
		buf_mpz[i].clear();
		for (RBC_BufferList::iterator lit = buf_id[i].begin();
			lit != buf_id[i].end(); ++lit)
		{
			mpz_clear(*lit);
			delete [] *lit;
		}
		buf_id[i].clear();
		for (RBC_BufferList::iterator lit = buf_msg[i].begin();
			lit != buf_msg[i].end(); ++lit)
		{
			mpz_clear(*lit);
			delete [] *lit;
		}
		buf_msg[i].clear();
		mpz_clear(deliver_s[i]);
		delete [] deliver_s[i];
	}
	buf_mpz.clear(), buf_id.clear(), buf_msg.clear(), deliver_s.clear();
	for (RBC_VectorList::iterator lit = deliver_buf.begin();
		lit != deliver_buf.end(); ++lit)
	{
		for (RBC_Message::iterator vit = lit->begin(); vit != lit->end(); ++vit)
		{
			mpz_clear(*vit);
			delete [] *vit;
		}
		lit->clear();
	}	
	deliver_buf.clear(), deliver_error.clear();
}

